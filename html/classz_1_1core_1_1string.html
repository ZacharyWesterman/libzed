<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libzed: z::core::string&lt; E &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libzed
   &#160;<span id="projectnumber">1.5</span>
   </div>
   <div id="projectbrief">Code libraries for use in other projects</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classz_1_1core_1_1string.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classz_1_1core_1_1string-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">z::core::string&lt; E &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A template class for character strings.  
 <a href="classz_1_1core_1_1string.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="string_8hpp_source.html">string.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for z::core::string&lt; E &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classz_1_1core_1_1string.png" usemap="#z::core::string_3C_20E_20_3E_map" alt=""/>
  <map id="z::core::string_3C_20E_20_3E_map" name="z::core::string_3C_20E_20_3E_map">
<area href="classz_1_1core_1_1sizable.html" title="An interface for getting an object&#39;s size." alt="z::core::sizable" shape="rect" coords="0,0,119,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a73b71c3ef2cf068929580628839d2903"><td class="memItemLeft" align="right" valign="top"><a id="a73b71c3ef2cf068929580628839d2903"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a73b71c3ef2cf068929580628839d2903">string</a> () noexcept</td></tr>
<tr class="memdesc:a73b71c3ef2cf068929580628839d2903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default string constructor. <br /></td></tr>
<tr class="separator:a73b71c3ef2cf068929580628839d2903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dac1aad193774be2919f3c7e8e9666b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a3dac1aad193774be2919f3c7e8e9666b">string</a> (char chr) noexcept</td></tr>
<tr class="memdesc:a3dac1aad193774be2919f3c7e8e9666b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct string from a single-byte character.  <a href="classz_1_1core_1_1string.html#a3dac1aad193774be2919f3c7e8e9666b">More...</a><br /></td></tr>
<tr class="separator:a3dac1aad193774be2919f3c7e8e9666b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb6bd9a9a9447b23d3fb804586b8880"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aceb6bd9a9a9447b23d3fb804586b8880">string</a> (wchar_t chr) noexcept</td></tr>
<tr class="memdesc:aceb6bd9a9a9447b23d3fb804586b8880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct string from a wide character.  <a href="classz_1_1core_1_1string.html#aceb6bd9a9a9447b23d3fb804586b8880">More...</a><br /></td></tr>
<tr class="separator:aceb6bd9a9a9447b23d3fb804586b8880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6987eedf472fa0b1f5f32cb4dfa16141"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a6987eedf472fa0b1f5f32cb4dfa16141">string</a> (const uint32_t &amp;chr) noexcept</td></tr>
<tr class="memdesc:a6987eedf472fa0b1f5f32cb4dfa16141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct string from uint32_t.  <a href="classz_1_1core_1_1string.html#a6987eedf472fa0b1f5f32cb4dfa16141">More...</a><br /></td></tr>
<tr class="separator:a6987eedf472fa0b1f5f32cb4dfa16141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a85952a47b96150a7f3f540535bdd25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a1a85952a47b96150a7f3f540535bdd25">string</a> (const char *str) noexcept</td></tr>
<tr class="memdesc:a1a85952a47b96150a7f3f540535bdd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a cstring of single-byte characters.  <a href="classz_1_1core_1_1string.html#a1a85952a47b96150a7f3f540535bdd25">More...</a><br /></td></tr>
<tr class="separator:a1a85952a47b96150a7f3f540535bdd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9e76587629cc1cc42435c1646ef424"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aee9e76587629cc1cc42435c1646ef424">string</a> (const wchar_t *str) noexcept</td></tr>
<tr class="memdesc:aee9e76587629cc1cc42435c1646ef424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a cstring of wide characters.  <a href="classz_1_1core_1_1string.html#aee9e76587629cc1cc42435c1646ef424">More...</a><br /></td></tr>
<tr class="separator:aee9e76587629cc1cc42435c1646ef424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cd477dde33d3272f9780cec18297ef"><td class="memTemplParams" colspan="2">template&lt;typename INT , typename  = typename std::enable_if&lt;				std::is_integral&lt;INT&gt;::value &amp;&amp; !std::is_same&lt;INT,char&gt;::value &amp;&amp; !std::is_same&lt;INT,wchar_t&gt;::value				,INT&gt;::type&gt; </td></tr>
<tr class="memitem:a24cd477dde33d3272f9780cec18297ef"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a24cd477dde33d3272f9780cec18297ef">string</a> (INT value, int base=10, int padSize=0) noexcept</td></tr>
<tr class="memdesc:a24cd477dde33d3272f9780cec18297ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from an integer.  <a href="classz_1_1core_1_1string.html#a24cd477dde33d3272f9780cec18297ef">More...</a><br /></td></tr>
<tr class="separator:a24cd477dde33d3272f9780cec18297ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bed0f235b563c4c200bcb7a24f6374"><td class="memTemplParams" colspan="2">template&lt;typename PTR , typename  = typename std::enable_if&lt;				std::is_pointer&lt;PTR&gt;::value &amp;&amp; !std::is_same&lt;PTR,char*&gt;::value &amp;&amp; !std::is_same&lt;PTR,wchar_t*&gt;::value				,PTR&gt;::type&gt; </td></tr>
<tr class="memitem:ab8bed0f235b563c4c200bcb7a24f6374"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ab8bed0f235b563c4c200bcb7a24f6374">string</a> (PTR pointer) noexcept</td></tr>
<tr class="memdesc:ab8bed0f235b563c4c200bcb7a24f6374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a pointer.  <a href="classz_1_1core_1_1string.html#ab8bed0f235b563c4c200bcb7a24f6374">More...</a><br /></td></tr>
<tr class="separator:ab8bed0f235b563c4c200bcb7a24f6374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884576fbd00bc546b858771288041d42"><td class="memTemplParams" colspan="2">template&lt;typename FLT , typename  = typename std::enable_if&lt;std::is_floating_point&lt;FLT&gt;::value,FLT&gt;::type&gt; </td></tr>
<tr class="memitem:a884576fbd00bc546b858771288041d42"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a884576fbd00bc546b858771288041d42">string</a> (FLT value, int base=10, int precision=0, bool scientific=true, int padSize=0) noexcept</td></tr>
<tr class="memdesc:a884576fbd00bc546b858771288041d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from floating-point.  <a href="classz_1_1core_1_1string.html#a884576fbd00bc546b858771288041d42">More...</a><br /></td></tr>
<tr class="separator:a884576fbd00bc546b858771288041d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0271bd586225ca6a9a0492ed66b4ae82"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value,T&gt;::type&gt; </td></tr>
<tr class="memitem:a0271bd586225ca6a9a0492ed66b4ae82"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a0271bd586225ca6a9a0492ed66b4ae82">string</a> (const std::complex&lt; T &gt; &amp;value, int base=10, int precision=0, bool scientific=true, int padSize=0) noexcept</td></tr>
<tr class="memdesc:a0271bd586225ca6a9a0492ed66b4ae82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from complex number.  <a href="classz_1_1core_1_1string.html#a0271bd586225ca6a9a0492ed66b4ae82">More...</a><br /></td></tr>
<tr class="separator:a0271bd586225ca6a9a0492ed66b4ae82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1d79e87ce3f2c0a5d92a97c598216f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a2a1d79e87ce3f2c0a5d92a97c598216f">string</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; ascii &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a2a1d79e87ce3f2c0a5d92a97c598216f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from an ASCII string.  <a href="classz_1_1core_1_1string.html#a2a1d79e87ce3f2c0a5d92a97c598216f">More...</a><br /></td></tr>
<tr class="separator:a2a1d79e87ce3f2c0a5d92a97c598216f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec23d43fa2edf50af7e1a08a272173b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a8ec23d43fa2edf50af7e1a08a272173b">string</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; utf8 &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a8ec23d43fa2edf50af7e1a08a272173b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a UTF-8 string.  <a href="classz_1_1core_1_1string.html#a8ec23d43fa2edf50af7e1a08a272173b">More...</a><br /></td></tr>
<tr class="separator:a8ec23d43fa2edf50af7e1a08a272173b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e0a419764c155d24f17d6b76239909"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a78e0a419764c155d24f17d6b76239909">string</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; utf16 &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a78e0a419764c155d24f17d6b76239909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a UTF16 string.  <a href="classz_1_1core_1_1string.html#a78e0a419764c155d24f17d6b76239909">More...</a><br /></td></tr>
<tr class="separator:a78e0a419764c155d24f17d6b76239909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5858ead5f3e043184af3ae731d87ad85"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a5858ead5f3e043184af3ae731d87ad85">string</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; utf32 &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a5858ead5f3e043184af3ae731d87ad85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a UTF32 string.  <a href="classz_1_1core_1_1string.html#a5858ead5f3e043184af3ae731d87ad85">More...</a><br /></td></tr>
<tr class="separator:a5858ead5f3e043184af3ae731d87ad85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae874c9d0a4107c1891b91218068266cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ae874c9d0a4107c1891b91218068266cd">string</a> (<a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ae874c9d0a4107c1891b91218068266cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classz_1_1core_1_1string.html#ae874c9d0a4107c1891b91218068266cd">More...</a><br /></td></tr>
<tr class="separator:ae874c9d0a4107c1891b91218068266cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed3abe80b423c9e0cf3a1c40ef70733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a0ed3abe80b423c9e0cf3a1c40ef70733">operator=</a> (<a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a0ed3abe80b423c9e0cf3a1c40ef70733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classz_1_1core_1_1string.html#a0ed3abe80b423c9e0cf3a1c40ef70733">More...</a><br /></td></tr>
<tr class="separator:a0ed3abe80b423c9e0cf3a1c40ef70733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63330bb4cd06265520bd062cffba446b"><td class="memItemLeft" align="right" valign="top"><a id="a63330bb4cd06265520bd062cffba446b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a63330bb4cd06265520bd062cffba446b">~string</a> () noexcept</td></tr>
<tr class="memdesc:a63330bb4cd06265520bd062cffba446b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a63330bb4cd06265520bd062cffba446b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac428c7c81a4b4b76cfa8b68eafa00076"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ac428c7c81a4b4b76cfa8b68eafa00076">increase</a> (int charCount) noexcept</td></tr>
<tr class="memdesc:ac428c7c81a4b4b76cfa8b68eafa00076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the space allocated for this string.  <a href="classz_1_1core_1_1string.html#ac428c7c81a4b4b76cfa8b68eafa00076">More...</a><br /></td></tr>
<tr class="separator:ac428c7c81a4b4b76cfa8b68eafa00076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037e988d7f9349740b59d0d74ff22aeb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a037e988d7f9349740b59d0d74ff22aeb">at</a> (int index) const noexcept</td></tr>
<tr class="memdesc:a037e988d7f9349740b59d0d74ff22aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the character at the given index.  <a href="classz_1_1core_1_1string.html#a037e988d7f9349740b59d0d74ff22aeb">More...</a><br /></td></tr>
<tr class="separator:a037e988d7f9349740b59d0d74ff22aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee85973dffb32fc45cfb1080f0e7ecd6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aee85973dffb32fc45cfb1080f0e7ecd6">operator[]</a> (int index) const noexcept</td></tr>
<tr class="memdesc:aee85973dffb32fc45cfb1080f0e7ecd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the character at the given index.  <a href="classz_1_1core_1_1string.html#aee85973dffb32fc45cfb1080f0e7ecd6">More...</a><br /></td></tr>
<tr class="separator:aee85973dffb32fc45cfb1080f0e7ecd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961659a5ec0b38a0c48ff2ed6f0c2f56"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a961659a5ec0b38a0c48ff2ed6f0c2f56">size</a> () const noexcept</td></tr>
<tr class="memdesc:a961659a5ec0b38a0c48ff2ed6f0c2f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the string in memory.  <a href="classz_1_1core_1_1string.html#a961659a5ec0b38a0c48ff2ed6f0c2f56">More...</a><br /></td></tr>
<tr class="separator:a961659a5ec0b38a0c48ff2ed6f0c2f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c25e8c1e48ddb23e1d67327811f645"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a09c25e8c1e48ddb23e1d67327811f645">length</a> () const noexcept</td></tr>
<tr class="memdesc:a09c25e8c1e48ddb23e1d67327811f645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the character count of the string.  <a href="classz_1_1core_1_1string.html#a09c25e8c1e48ddb23e1d67327811f645">More...</a><br /></td></tr>
<tr class="separator:a09c25e8c1e48ddb23e1d67327811f645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb98c8ecf3aa9a78a59d88cf2a94c7bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#adb98c8ecf3aa9a78a59d88cf2a94c7bc">chars</a> () const noexcept</td></tr>
<tr class="memdesc:adb98c8ecf3aa9a78a59d88cf2a94c7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the individual character count of the string.  <a href="classz_1_1core_1_1string.html#adb98c8ecf3aa9a78a59d88cf2a94c7bc">More...</a><br /></td></tr>
<tr class="separator:adb98c8ecf3aa9a78a59d88cf2a94c7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5954e333c390718fe085e930bbf7317"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ac5954e333c390718fe085e930bbf7317">cstring</a> () const noexcept</td></tr>
<tr class="memdesc:ac5954e333c390718fe085e930bbf7317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the single-byte cstring pointer.  <a href="classz_1_1core_1_1string.html#ac5954e333c390718fe085e930bbf7317">More...</a><br /></td></tr>
<tr class="separator:ac5954e333c390718fe085e930bbf7317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99b04cc2a3751516f49cb654d213356"><td class="memItemLeft" align="right" valign="top">const uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ac99b04cc2a3751516f49cb654d213356">nstring</a> () const noexcept</td></tr>
<tr class="memdesc:ac99b04cc2a3751516f49cb654d213356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the two-byte cstring pointer.  <a href="classz_1_1core_1_1string.html#ac99b04cc2a3751516f49cb654d213356">More...</a><br /></td></tr>
<tr class="separator:ac99b04cc2a3751516f49cb654d213356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca71321f6cc1fca3825fee6c05a9db7"><td class="memItemLeft" align="right" valign="top">const uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a0ca71321f6cc1fca3825fee6c05a9db7">wstring</a> () const noexcept</td></tr>
<tr class="memdesc:a0ca71321f6cc1fca3825fee6c05a9db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the four-byte cstring pointer.  <a href="classz_1_1core_1_1string.html#a0ca71321f6cc1fca3825fee6c05a9db7">More...</a><br /></td></tr>
<tr class="separator:a0ca71321f6cc1fca3825fee6c05a9db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af080f57c9f262b48e15e7d85d500e3f8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="encoding_8hpp.html#abb9b3bdd67c870c617a43438ebb64c17">encoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#af080f57c9f262b48e15e7d85d500e3f8">format</a> () const noexcept</td></tr>
<tr class="memdesc:af080f57c9f262b48e15e7d85d500e3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the encoding of this string.  <a href="classz_1_1core_1_1string.html#af080f57c9f262b48e15e7d85d500e3f8">More...</a><br /></td></tr>
<tr class="separator:af080f57c9f262b48e15e7d85d500e3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ea919808135fd2ac1e19231e6eb94a"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a41ea919808135fd2ac1e19231e6eb94a">integer</a> (int base=10, uint32_t decimal='.') const noexcept</td></tr>
<tr class="memdesc:a41ea919808135fd2ac1e19231e6eb94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this string to an integer.  <a href="classz_1_1core_1_1string.html#a41ea919808135fd2ac1e19231e6eb94a">More...</a><br /></td></tr>
<tr class="separator:a41ea919808135fd2ac1e19231e6eb94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8b8c3e5d8cf56e10ea6ef2f19f8acc"><td class="memTemplParams" colspan="2">template&lt;typename INT , typename  = typename std::enable_if&lt;std::is_integral&lt;INT&gt;::value,INT&gt;::type&gt; </td></tr>
<tr class="memitem:afe8b8c3e5d8cf56e10ea6ef2f19f8acc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#afe8b8c3e5d8cf56e10ea6ef2f19f8acc">operator INT</a> () const noexcept</td></tr>
<tr class="memdesc:afe8b8c3e5d8cf56e10ea6ef2f19f8acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this string to an integer.  <a href="classz_1_1core_1_1string.html#afe8b8c3e5d8cf56e10ea6ef2f19f8acc">More...</a><br /></td></tr>
<tr class="separator:afe8b8c3e5d8cf56e10ea6ef2f19f8acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d27dfd8e5df8288d8859c087fe67cc1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a3d27dfd8e5df8288d8859c087fe67cc1">floating</a> (int base=10, uint32_t decimal='.') const noexcept</td></tr>
<tr class="memdesc:a3d27dfd8e5df8288d8859c087fe67cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this string to a floating-point value.  <a href="classz_1_1core_1_1string.html#a3d27dfd8e5df8288d8859c087fe67cc1">More...</a><br /></td></tr>
<tr class="separator:a3d27dfd8e5df8288d8859c087fe67cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe2be987f0a6972683f1b84b2fc0754"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#acfe2be987f0a6972683f1b84b2fc0754">operator double</a> () const noexcept</td></tr>
<tr class="memdesc:acfe2be987f0a6972683f1b84b2fc0754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this string to a floating-point value.  <a href="classz_1_1core_1_1string.html#acfe2be987f0a6972683f1b84b2fc0754">More...</a><br /></td></tr>
<tr class="separator:acfe2be987f0a6972683f1b84b2fc0754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d8e2bc02221468f5526f5739b0ec9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a04d8e2bc02221468f5526f5739b0ec9d">operator float</a> () const noexcept</td></tr>
<tr class="memdesc:a04d8e2bc02221468f5526f5739b0ec9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this string to a floating-point value.  <a href="classz_1_1core_1_1string.html#a04d8e2bc02221468f5526f5739b0ec9d">More...</a><br /></td></tr>
<tr class="separator:a04d8e2bc02221468f5526f5739b0ec9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7ee171c8c23c2de9b8e691c557b9da"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aec7ee171c8c23c2de9b8e691c557b9da">complex</a> (int base=10, uint32_t decimal='.') const noexcept</td></tr>
<tr class="memdesc:aec7ee171c8c23c2de9b8e691c557b9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this string to a complex value.  <a href="classz_1_1core_1_1string.html#aec7ee171c8c23c2de9b8e691c557b9da">More...</a><br /></td></tr>
<tr class="separator:aec7ee171c8c23c2de9b8e691c557b9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b0f9f2dc434e125a09f9d0b41b4d06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a12b0f9f2dc434e125a09f9d0b41b4d06">count</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a12b0f9f2dc434e125a09f9d0b41b4d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the occurrences of a sub-string.  <a href="classz_1_1core_1_1string.html#a12b0f9f2dc434e125a09f9d0b41b4d06">More...</a><br /></td></tr>
<tr class="separator:a12b0f9f2dc434e125a09f9d0b41b4d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f3b6f5a58ea7e8857a5bc19ac9e248"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a17f3b6f5a58ea7e8857a5bc19ac9e248">find</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, int occurrence=1) const noexcept</td></tr>
<tr class="memdesc:a17f3b6f5a58ea7e8857a5bc19ac9e248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a specific occurrence of a sub-string.  <a href="classz_1_1core_1_1string.html#a17f3b6f5a58ea7e8857a5bc19ac9e248">More...</a><br /></td></tr>
<tr class="separator:a17f3b6f5a58ea7e8857a5bc19ac9e248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515118a25d1706ee8e91754c30d55218"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a515118a25d1706ee8e91754c30d55218">findLast</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, int occurrence=1) const noexcept</td></tr>
<tr class="memdesc:a515118a25d1706ee8e91754c30d55218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse-find a specific occurrence of a sub-string.  <a href="classz_1_1core_1_1string.html#a515118a25d1706ee8e91754c30d55218">More...</a><br /></td></tr>
<tr class="separator:a515118a25d1706ee8e91754c30d55218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2f2d957cc32c166bfb80b3b701ee08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a9d2f2d957cc32c166bfb80b3b701ee08">findAfter</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, int index, int occurrence=1) const noexcept</td></tr>
<tr class="memdesc:a9d2f2d957cc32c166bfb80b3b701ee08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a specific occurrence of a sub-string.  <a href="classz_1_1core_1_1string.html#a9d2f2d957cc32c166bfb80b3b701ee08">More...</a><br /></td></tr>
<tr class="separator:a9d2f2d957cc32c166bfb80b3b701ee08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c542fcf7f12913c2d3af154c300c28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aa9c542fcf7f12913c2d3af154c300c28">findBefore</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, int index, int occurrence=1) const noexcept</td></tr>
<tr class="memdesc:aa9c542fcf7f12913c2d3af154c300c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse-find a specific occurrence of a sub-string.  <a href="classz_1_1core_1_1string.html#aa9c542fcf7f12913c2d3af154c300c28">More...</a><br /></td></tr>
<tr class="separator:aa9c542fcf7f12913c2d3af154c300c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88d54285e20d23be6bb69edfef9ebbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ad88d54285e20d23be6bb69edfef9ebbc">foundAt</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, int index) const noexcept</td></tr>
<tr class="memdesc:ad88d54285e20d23be6bb69edfef9ebbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a sub-string is found at the given index.  <a href="classz_1_1core_1_1string.html#ad88d54285e20d23be6bb69edfef9ebbc">More...</a><br /></td></tr>
<tr class="separator:ad88d54285e20d23be6bb69edfef9ebbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e23641e0457fa6c3b371e6b5d5e30dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a2e23641e0457fa6c3b371e6b5d5e30dc">foundEndAt</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, int index) const noexcept</td></tr>
<tr class="memdesc:a2e23641e0457fa6c3b371e6b5d5e30dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a sub-string ends at the given index.  <a href="classz_1_1core_1_1string.html#a2e23641e0457fa6c3b371e6b5d5e30dc">More...</a><br /></td></tr>
<tr class="separator:a2e23641e0457fa6c3b371e6b5d5e30dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1371419b27c739ff80f47661fd4c17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#abc1371419b27c739ff80f47661fd4c17">beginsWith</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:abc1371419b27c739ff80f47661fd4c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the string begins with a given sub-string.  <a href="classz_1_1core_1_1string.html#abc1371419b27c739ff80f47661fd4c17">More...</a><br /></td></tr>
<tr class="separator:abc1371419b27c739ff80f47661fd4c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410f2a23a73f84f5f3c0194587a57697"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a410f2a23a73f84f5f3c0194587a57697">endsWith</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a410f2a23a73f84f5f3c0194587a57697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the string ends with a given sub-string.  <a href="classz_1_1core_1_1string.html#a410f2a23a73f84f5f3c0194587a57697">More...</a><br /></td></tr>
<tr class="separator:a410f2a23a73f84f5f3c0194587a57697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010ccdee32ca8973fee25eaeab2e64dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a010ccdee32ca8973fee25eaeab2e64dc">isInteger</a> (int base=10) const noexcept</td></tr>
<tr class="memdesc:a010ccdee32ca8973fee25eaeab2e64dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string can convert to an integer.  <a href="classz_1_1core_1_1string.html#a010ccdee32ca8973fee25eaeab2e64dc">More...</a><br /></td></tr>
<tr class="separator:a010ccdee32ca8973fee25eaeab2e64dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1cd83fd6ca82ac6f2a9e92562804a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#afe1cd83fd6ca82ac6f2a9e92562804a0">isFloating</a> (int base=10, uint32_t decimal='.') const noexcept</td></tr>
<tr class="memdesc:afe1cd83fd6ca82ac6f2a9e92562804a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string can convert to a floating-point value.  <a href="classz_1_1core_1_1string.html#afe1cd83fd6ca82ac6f2a9e92562804a0">More...</a><br /></td></tr>
<tr class="separator:afe1cd83fd6ca82ac6f2a9e92562804a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f2edc11684860b5741f614d0ddf384"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a70f2edc11684860b5741f614d0ddf384">isComplex</a> (int base=10, uint32_t decimal='.') const noexcept</td></tr>
<tr class="memdesc:a70f2edc11684860b5741f614d0ddf384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string can convert to a complex value.  <a href="classz_1_1core_1_1string.html#a70f2edc11684860b5741f614d0ddf384">More...</a><br /></td></tr>
<tr class="separator:a70f2edc11684860b5741f614d0ddf384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8644b4f7292302682dd4aae86a0c2b4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a8644b4f7292302682dd4aae86a0c2b4d">type</a> (int base=10, uint32_t decimal='.') const noexcept</td></tr>
<tr class="memdesc:a8644b4f7292302682dd4aae86a0c2b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the most basic type that this string can cast to.  <a href="classz_1_1core_1_1string.html#a8644b4f7292302682dd4aae86a0c2b4d">More...</a><br /></td></tr>
<tr class="separator:a8644b4f7292302682dd4aae86a0c2b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa571037a910a6408277e5d823a15fa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aaa571037a910a6408277e5d823a15fa8">substr</a> (int index, int <a class="el" href="classz_1_1core_1_1string.html#a12b0f9f2dc434e125a09f9d0b41b4d06">count</a>) const noexcept</td></tr>
<tr class="memdesc:aaa571037a910a6408277e5d823a15fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a sub-string from this string.  <a href="classz_1_1core_1_1string.html#aaa571037a910a6408277e5d823a15fa8">More...</a><br /></td></tr>
<tr class="separator:aaa571037a910a6408277e5d823a15fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a7f895948b49fcc302bc12d8c7f52b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a01a7f895948b49fcc302bc12d8c7f52b">append</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a01a7f895948b49fcc302bc12d8c7f52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append another string to the end of this one.  <a href="classz_1_1core_1_1string.html#a01a7f895948b49fcc302bc12d8c7f52b">More...</a><br /></td></tr>
<tr class="separator:a01a7f895948b49fcc302bc12d8c7f52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac189b8ddeb0f81b7921a7b870083c0eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ac189b8ddeb0f81b7921a7b870083c0eb">append</a> (uint32_t chr) noexcept</td></tr>
<tr class="memdesc:ac189b8ddeb0f81b7921a7b870083c0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a single character to the end of the string.  <a href="classz_1_1core_1_1string.html#ac189b8ddeb0f81b7921a7b870083c0eb">More...</a><br /></td></tr>
<tr class="separator:ac189b8ddeb0f81b7921a7b870083c0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3314be548e8d54690b8c6de47b7e7bcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a3314be548e8d54690b8c6de47b7e7bcb">insert</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, int index) noexcept</td></tr>
<tr class="memdesc:a3314be548e8d54690b8c6de47b7e7bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert another string into this one.  <a href="classz_1_1core_1_1string.html#a3314be548e8d54690b8c6de47b7e7bcb">More...</a><br /></td></tr>
<tr class="separator:a3314be548e8d54690b8c6de47b7e7bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4859c295acebf35c40a892af33ef4a65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a4859c295acebf35c40a892af33ef4a65">remove</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, int occurrence=0) noexcept</td></tr>
<tr class="memdesc:a4859c295acebf35c40a892af33ef4a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove occurrences of the given sub-string.  <a href="classz_1_1core_1_1string.html#a4859c295acebf35c40a892af33ef4a65">More...</a><br /></td></tr>
<tr class="separator:a4859c295acebf35c40a892af33ef4a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f96aebbcd4cd47a3f407967900064c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ac1f96aebbcd4cd47a3f407967900064c">remove</a> (int index, int <a class="el" href="classz_1_1core_1_1string.html#a12b0f9f2dc434e125a09f9d0b41b4d06">count</a>) noexcept</td></tr>
<tr class="memdesc:ac1f96aebbcd4cd47a3f407967900064c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a subset of the string.  <a href="classz_1_1core_1_1string.html#ac1f96aebbcd4cd47a3f407967900064c">More...</a><br /></td></tr>
<tr class="separator:ac1f96aebbcd4cd47a3f407967900064c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79115a233e715c328a27e051264f9248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a79115a233e715c328a27e051264f9248">truncate</a> (int index) noexcept</td></tr>
<tr class="memdesc:a79115a233e715c328a27e051264f9248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all characters from a given index to the end of the string.  <a href="classz_1_1core_1_1string.html#a79115a233e715c328a27e051264f9248">More...</a><br /></td></tr>
<tr class="separator:a79115a233e715c328a27e051264f9248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d961c716fd579f8c166a9fc662752c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a5d961c716fd579f8c166a9fc662752c1">replace</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;findStr, const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;replStr, int occurrence=0) noexcept</td></tr>
<tr class="memdesc:a5d961c716fd579f8c166a9fc662752c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace occurrences of the given sub-string.  <a href="classz_1_1core_1_1string.html#a5d961c716fd579f8c166a9fc662752c1">More...</a><br /></td></tr>
<tr class="separator:a5d961c716fd579f8c166a9fc662752c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0112c15e36a180f3719f21db0cd0b9d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a0112c15e36a180f3719f21db0cd0b9d6">replace</a> (int index, int <a class="el" href="classz_1_1core_1_1string.html#a12b0f9f2dc434e125a09f9d0b41b4d06">count</a>, const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a0112c15e36a180f3719f21db0cd0b9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a subset of the string.  <a href="classz_1_1core_1_1string.html#a0112c15e36a180f3719f21db0cd0b9d6">More...</a><br /></td></tr>
<tr class="separator:a0112c15e36a180f3719f21db0cd0b9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2005c7a79afc14b62ac9db2f771b82bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a2005c7a79afc14b62ac9db2f771b82bf">padLeft</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, int padSize) const noexcept</td></tr>
<tr class="memdesc:a2005c7a79afc14b62ac9db2f771b82bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy this string, left-padded given character count.  <a href="classz_1_1core_1_1string.html#a2005c7a79afc14b62ac9db2f771b82bf">More...</a><br /></td></tr>
<tr class="separator:a2005c7a79afc14b62ac9db2f771b82bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a9196e39c9db62eace90b131fb4672"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ae8a9196e39c9db62eace90b131fb4672">padLeftIn</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, int padSize) noexcept</td></tr>
<tr class="memdesc:ae8a9196e39c9db62eace90b131fb4672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-pad this string up to a given character count.  <a href="classz_1_1core_1_1string.html#ae8a9196e39c9db62eace90b131fb4672">More...</a><br /></td></tr>
<tr class="separator:ae8a9196e39c9db62eace90b131fb4672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4177775bd189938a963d902bb41d6520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a4177775bd189938a963d902bb41d6520">padRight</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, int padSize) const noexcept</td></tr>
<tr class="memdesc:a4177775bd189938a963d902bb41d6520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy this string, right-padded given character count.  <a href="classz_1_1core_1_1string.html#a4177775bd189938a963d902bb41d6520">More...</a><br /></td></tr>
<tr class="separator:a4177775bd189938a963d902bb41d6520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3150636a59c7307ecea99d10a6b1f034"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a3150636a59c7307ecea99d10a6b1f034">padRightIn</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, int padSize) noexcept</td></tr>
<tr class="memdesc:a3150636a59c7307ecea99d10a6b1f034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-pad this string up to a given character count.  <a href="classz_1_1core_1_1string.html#a3150636a59c7307ecea99d10a6b1f034">More...</a><br /></td></tr>
<tr class="separator:a3150636a59c7307ecea99d10a6b1f034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3d553c79a0a897becf916d6d2c5469"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aac3d553c79a0a897becf916d6d2c5469">repeat</a> (int <a class="el" href="classz_1_1core_1_1string.html#a12b0f9f2dc434e125a09f9d0b41b4d06">count</a>) const noexcept</td></tr>
<tr class="memdesc:aac3d553c79a0a897becf916d6d2c5469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat this string a specific number of times.  <a href="classz_1_1core_1_1string.html#aac3d553c79a0a897becf916d6d2c5469">More...</a><br /></td></tr>
<tr class="separator:aac3d553c79a0a897becf916d6d2c5469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1c45a217805b32f69041c5812fcee3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a3c1c45a217805b32f69041c5812fcee3">trimLeft</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other=&quot;&quot;) const noexcept</td></tr>
<tr class="memdesc:a3c1c45a217805b32f69041c5812fcee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies this string and removes padding from the left side of the result.  <a href="classz_1_1core_1_1string.html#a3c1c45a217805b32f69041c5812fcee3">More...</a><br /></td></tr>
<tr class="separator:a3c1c45a217805b32f69041c5812fcee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8da0a78e38d9b7abb145721f78ad29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a9f8da0a78e38d9b7abb145721f78ad29">trimRight</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other=&quot;&quot;) const noexcept</td></tr>
<tr class="memdesc:a9f8da0a78e38d9b7abb145721f78ad29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies this string and removes padding from the right side of the result.  <a href="classz_1_1core_1_1string.html#a9f8da0a78e38d9b7abb145721f78ad29">More...</a><br /></td></tr>
<tr class="separator:a9f8da0a78e38d9b7abb145721f78ad29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039bb45cdf70ff3d3334d19e735b42ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a039bb45cdf70ff3d3334d19e735b42ac">trimLeftIn</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other=&quot;&quot;) noexcept</td></tr>
<tr class="memdesc:a039bb45cdf70ff3d3334d19e735b42ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove padding from the left side of this string.  <a href="classz_1_1core_1_1string.html#a039bb45cdf70ff3d3334d19e735b42ac">More...</a><br /></td></tr>
<tr class="separator:a039bb45cdf70ff3d3334d19e735b42ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afaf63293096ee1d74ebc25bffef82e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a8afaf63293096ee1d74ebc25bffef82e">trimRightIn</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other=&quot;&quot;) noexcept</td></tr>
<tr class="memdesc:a8afaf63293096ee1d74ebc25bffef82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove padding from the right side of this string.  <a href="classz_1_1core_1_1string.html#a8afaf63293096ee1d74ebc25bffef82e">More...</a><br /></td></tr>
<tr class="separator:a8afaf63293096ee1d74ebc25bffef82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3047a75dfc29b79f0e956e6c1adda93d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a3047a75dfc29b79f0e956e6c1adda93d">trim</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other=&quot;&quot;) const noexcept</td></tr>
<tr class="memdesc:a3047a75dfc29b79f0e956e6c1adda93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies this string and removes padding from both sides of the result.  <a href="classz_1_1core_1_1string.html#a3047a75dfc29b79f0e956e6c1adda93d">More...</a><br /></td></tr>
<tr class="separator:a3047a75dfc29b79f0e956e6c1adda93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ab15bdfd5a290e04e07b2cd34cbc05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a28ab15bdfd5a290e04e07b2cd34cbc05">trimIn</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other=&quot;&quot;) noexcept</td></tr>
<tr class="memdesc:a28ab15bdfd5a290e04e07b2cd34cbc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove padding from the both sides of this string.  <a href="classz_1_1core_1_1string.html#a28ab15bdfd5a290e04e07b2cd34cbc05">More...</a><br /></td></tr>
<tr class="separator:a28ab15bdfd5a290e04e07b2cd34cbc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81636d4790a5f15b15e188a906cedfb"><td class="memItemLeft" align="right" valign="top"><a id="ab81636d4790a5f15b15e188a906cedfb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ab81636d4790a5f15b15e188a906cedfb">clear</a> () noexcept</td></tr>
<tr class="memdesc:ab81636d4790a5f15b15e188a906cedfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to a null string. <br /></td></tr>
<tr class="separator:ab81636d4790a5f15b15e188a906cedfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c9f412dbc1c8a30695c8accb169ba4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a32c9f412dbc1c8a30695c8accb169ba4">cutDuplicates</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a32c9f412dbc1c8a30695c8accb169ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all sequential duplicates from this string.  <a href="classz_1_1core_1_1string.html#a32c9f412dbc1c8a30695c8accb169ba4">More...</a><br /></td></tr>
<tr class="separator:a32c9f412dbc1c8a30695c8accb169ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0d76eb1977c8ece5bd35f41faa9178"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#abe0d76eb1977c8ece5bd35f41faa9178">upper</a> () const noexcept</td></tr>
<tr class="memdesc:abe0d76eb1977c8ece5bd35f41faa9178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an uppercase version of this string.  <a href="classz_1_1core_1_1string.html#abe0d76eb1977c8ece5bd35f41faa9178">More...</a><br /></td></tr>
<tr class="separator:abe0d76eb1977c8ece5bd35f41faa9178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1628e28d262fc80c69e89473500c93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a5a1628e28d262fc80c69e89473500c93">lower</a> () const noexcept</td></tr>
<tr class="memdesc:a5a1628e28d262fc80c69e89473500c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a lowercase version of this string.  <a href="classz_1_1core_1_1string.html#a5a1628e28d262fc80c69e89473500c93">More...</a><br /></td></tr>
<tr class="separator:a5a1628e28d262fc80c69e89473500c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6b4c3254762941ab789251f7f57836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a4f6b4c3254762941ab789251f7f57836">camel</a> () const noexcept</td></tr>
<tr class="memdesc:a4f6b4c3254762941ab789251f7f57836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a camelcase version of this string.  <a href="classz_1_1core_1_1string.html#a4f6b4c3254762941ab789251f7f57836">More...</a><br /></td></tr>
<tr class="separator:a4f6b4c3254762941ab789251f7f57836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f83606d111b9d0ab806a3a948de7c50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a3f83606d111b9d0ab806a3a948de7c50">toUpper</a> () noexcept</td></tr>
<tr class="memdesc:a3f83606d111b9d0ab806a3a948de7c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all characters in the string to uppercase.  <a href="classz_1_1core_1_1string.html#a3f83606d111b9d0ab806a3a948de7c50">More...</a><br /></td></tr>
<tr class="separator:a3f83606d111b9d0ab806a3a948de7c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8b7a630b01a5daaf2e81bd0e97aa26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ace8b7a630b01a5daaf2e81bd0e97aa26">toLower</a> () noexcept</td></tr>
<tr class="memdesc:ace8b7a630b01a5daaf2e81bd0e97aa26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all characters in the string to lowercase.  <a href="classz_1_1core_1_1string.html#ace8b7a630b01a5daaf2e81bd0e97aa26">More...</a><br /></td></tr>
<tr class="separator:ace8b7a630b01a5daaf2e81bd0e97aa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3853b1003f645ab83eae642779afa9e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a3853b1003f645ab83eae642779afa9e2">toCamel</a> () noexcept</td></tr>
<tr class="memdesc:a3853b1003f645ab83eae642779afa9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all characters in the string to camelcase.  <a href="classz_1_1core_1_1string.html#a3853b1003f645ab83eae642779afa9e2">More...</a><br /></td></tr>
<tr class="separator:a3853b1003f645ab83eae642779afa9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fd0f663f22e02dbcdabb6e12a12285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a45fd0f663f22e02dbcdabb6e12a12285">filter</a> (uint32_t first, uint32_t last, bool invert=false) const noexcept</td></tr>
<tr class="memdesc:a45fd0f663f22e02dbcdabb6e12a12285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter out all characters not in the given range.  <a href="classz_1_1core_1_1string.html#a45fd0f663f22e02dbcdabb6e12a12285">More...</a><br /></td></tr>
<tr class="separator:a45fd0f663f22e02dbcdabb6e12a12285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3926b94769d52b94e3abc8ec728c2335"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a3926b94769d52b94e3abc8ec728c2335">filter</a> (const std::pair&lt; uint32_t, uint32_t &gt; &amp;range, bool invert=false) const noexcept</td></tr>
<tr class="memdesc:a3926b94769d52b94e3abc8ec728c2335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter out all characters not in the given range.  <a href="classz_1_1core_1_1string.html#a3926b94769d52b94e3abc8ec728c2335">More...</a><br /></td></tr>
<tr class="separator:a3926b94769d52b94e3abc8ec728c2335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5e1fa34df91b2188d72e69e362344c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a1c5e1fa34df91b2188d72e69e362344c">filter</a> (const std::initializer_list&lt; const std::pair&lt; uint32_t, uint32_t &gt;&gt; &amp;list, bool invert=false) const noexcept</td></tr>
<tr class="memdesc:a1c5e1fa34df91b2188d72e69e362344c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter out all characters not in the given range.  <a href="classz_1_1core_1_1string.html#a1c5e1fa34df91b2188d72e69e362344c">More...</a><br /></td></tr>
<tr class="separator:a1c5e1fa34df91b2188d72e69e362344c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d1fdfec88d9dda0dc1766d6bba7c7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a06d1fdfec88d9dda0dc1766d6bba7c7b">filter</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;list, bool invert=false) const noexcept</td></tr>
<tr class="memdesc:a06d1fdfec88d9dda0dc1766d6bba7c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter out all characters not in the given string.  <a href="classz_1_1core_1_1string.html#a06d1fdfec88d9dda0dc1766d6bba7c7b">More...</a><br /></td></tr>
<tr class="separator:a06d1fdfec88d9dda0dc1766d6bba7c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681fe4167410b67fc551ba110ab05caf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a681fe4167410b67fc551ba110ab05caf">contains</a> (uint32_t first, uint32_t last, bool exclusive=false) const noexcept</td></tr>
<tr class="memdesc:a681fe4167410b67fc551ba110ab05caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string contains any characters in the given range.  <a href="classz_1_1core_1_1string.html#a681fe4167410b67fc551ba110ab05caf">More...</a><br /></td></tr>
<tr class="separator:a681fe4167410b67fc551ba110ab05caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47eb35c738fc945653b681f9ad833289"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a47eb35c738fc945653b681f9ad833289">contains</a> (const std::pair&lt; uint32_t, uint32_t &gt; &amp;range, bool exclusive=false) const noexcept</td></tr>
<tr class="memdesc:a47eb35c738fc945653b681f9ad833289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string contains any characters in the given range.  <a href="classz_1_1core_1_1string.html#a47eb35c738fc945653b681f9ad833289">More...</a><br /></td></tr>
<tr class="separator:a47eb35c738fc945653b681f9ad833289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b6fca4c36928c63442bd66738afde6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ad5b6fca4c36928c63442bd66738afde6">contains</a> (const std::initializer_list&lt; const std::pair&lt; uint32_t, uint32_t &gt;&gt; &amp;list, bool exclusive=false) const noexcept</td></tr>
<tr class="memdesc:ad5b6fca4c36928c63442bd66738afde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string contains any characters in the given ranges.  <a href="classz_1_1core_1_1string.html#ad5b6fca4c36928c63442bd66738afde6">More...</a><br /></td></tr>
<tr class="separator:ad5b6fca4c36928c63442bd66738afde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fad872ff436d306447bdb8fbda5650"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#af9fad872ff436d306447bdb8fbda5650">contains</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;list, bool exclusive=false) const noexcept</td></tr>
<tr class="memdesc:af9fad872ff436d306447bdb8fbda5650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string contains any of the characters in the given string.  <a href="classz_1_1core_1_1string.html#af9fad872ff436d306447bdb8fbda5650">More...</a><br /></td></tr>
<tr class="separator:af9fad872ff436d306447bdb8fbda5650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ea52347a2d0a44dad9e0cccda1449f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a27ea52347a2d0a44dad9e0cccda1449f">operator+</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a27ea52347a2d0a44dad9e0cccda1449f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two strings.  <a href="classz_1_1core_1_1string.html#a27ea52347a2d0a44dad9e0cccda1449f">More...</a><br /></td></tr>
<tr class="separator:a27ea52347a2d0a44dad9e0cccda1449f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fefb79339db522571cc239cadf31020"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a3fefb79339db522571cc239cadf31020">operator+=</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a3fefb79339db522571cc239cadf31020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append another string to the end of this one.  <a href="classz_1_1core_1_1string.html#a3fefb79339db522571cc239cadf31020">More...</a><br /></td></tr>
<tr class="separator:a3fefb79339db522571cc239cadf31020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b5be8cdb78daa62baad1c0786a7530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a75b5be8cdb78daa62baad1c0786a7530">operator=</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a75b5be8cdb78daa62baad1c0786a7530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the contents of this string.  <a href="classz_1_1core_1_1string.html#a75b5be8cdb78daa62baad1c0786a7530">More...</a><br /></td></tr>
<tr class="separator:a75b5be8cdb78daa62baad1c0786a7530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae8fdb335a58f12e3c5583fbcb053c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aeae8fdb335a58f12e3c5583fbcb053c9">operator==</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:aeae8fdb335a58f12e3c5583fbcb053c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison.  <a href="classz_1_1core_1_1string.html#aeae8fdb335a58f12e3c5583fbcb053c9">More...</a><br /></td></tr>
<tr class="separator:aeae8fdb335a58f12e3c5583fbcb053c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e986e795ba9985a3faff3d56cf300e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a19e986e795ba9985a3faff3d56cf300e">operator!=</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a19e986e795ba9985a3faff3d56cf300e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison.  <a href="classz_1_1core_1_1string.html#a19e986e795ba9985a3faff3d56cf300e">More...</a><br /></td></tr>
<tr class="separator:a19e986e795ba9985a3faff3d56cf300e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b71a49ce01ad6de4b49d7fb8f90f6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a52b71a49ce01ad6de4b49d7fb8f90f6f">operator&gt;</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a52b71a49ce01ad6de4b49d7fb8f90f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison.  <a href="classz_1_1core_1_1string.html#a52b71a49ce01ad6de4b49d7fb8f90f6f">More...</a><br /></td></tr>
<tr class="separator:a52b71a49ce01ad6de4b49d7fb8f90f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ab0b269111dc5a51da7583d1da9358"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a27ab0b269111dc5a51da7583d1da9358">operator&gt;=</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a27ab0b269111dc5a51da7583d1da9358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than or equal comparison.  <a href="classz_1_1core_1_1string.html#a27ab0b269111dc5a51da7583d1da9358">More...</a><br /></td></tr>
<tr class="separator:a27ab0b269111dc5a51da7583d1da9358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2d440a910caf4f4bc2b8d6e503ea0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aac2d440a910caf4f4bc2b8d6e503ea0a">operator&lt;</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:aac2d440a910caf4f4bc2b8d6e503ea0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison.  <a href="classz_1_1core_1_1string.html#aac2d440a910caf4f4bc2b8d6e503ea0a">More...</a><br /></td></tr>
<tr class="separator:aac2d440a910caf4f4bc2b8d6e503ea0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac882ad90bd12339c690e2978a06e1ed4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ac882ad90bd12339c690e2978a06e1ed4">operator&lt;=</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:ac882ad90bd12339c690e2978a06e1ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than or equal comparison.  <a href="classz_1_1core_1_1string.html#ac882ad90bd12339c690e2978a06e1ed4">More...</a><br /></td></tr>
<tr class="separator:ac882ad90bd12339c690e2978a06e1ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c810e7dee8c31bc799293ed5f120b13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a7c810e7dee8c31bc799293ed5f120b13">read</a> (<a class="el" href="classz_1_1core_1_1inputStream.html">inputStream</a> &amp;<a class="el" href="classz_1_1core_1_1stream.html">stream</a>, uint32_t delim=0) noexcept</td></tr>
<tr class="memdesc:a7c810e7dee8c31bc799293ed5f120b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read string data from a stream until the given delimiter is encountered.  <a href="classz_1_1core_1_1string.html#a7c810e7dee8c31bc799293ed5f120b13">More...</a><br /></td></tr>
<tr class="separator:a7c810e7dee8c31bc799293ed5f120b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197fec1700902dd7461f652fabceb7f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a197fec1700902dd7461f652fabceb7f0">readln</a> (<a class="el" href="classz_1_1core_1_1inputStream.html">inputStream</a> &amp;<a class="el" href="classz_1_1core_1_1stream.html">stream</a>) noexcept</td></tr>
<tr class="memdesc:a197fec1700902dd7461f652fabceb7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read string data from a stream until a newline is encountered.  <a href="classz_1_1core_1_1string.html#a197fec1700902dd7461f652fabceb7f0">More...</a><br /></td></tr>
<tr class="separator:a197fec1700902dd7461f652fabceb7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6bcc21f5c030820f9a582d93cee747"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#acf6bcc21f5c030820f9a582d93cee747">write</a> (<a class="el" href="classz_1_1core_1_1outputStream.html">outputStream</a> &amp;<a class="el" href="classz_1_1core_1_1stream.html">stream</a>, <a class="el" href="encoding_8hpp.html#abb9b3bdd67c870c617a43438ebb64c17">encoding</a> enc) const noexcept</td></tr>
<tr class="memdesc:acf6bcc21f5c030820f9a582d93cee747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write string data to a stream.  <a href="classz_1_1core_1_1string.html#acf6bcc21f5c030820f9a582d93cee747">More...</a><br /></td></tr>
<tr class="separator:acf6bcc21f5c030820f9a582d93cee747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d51094994baa05a0083222e4d588693"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a1d51094994baa05a0083222e4d588693">write</a> (<a class="el" href="classz_1_1core_1_1outputStream.html">outputStream</a> &amp;<a class="el" href="classz_1_1core_1_1stream.html">stream</a>) const noexcept</td></tr>
<tr class="memdesc:a1d51094994baa05a0083222e4d588693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write string data to a stream in that stream's encoding.  <a href="classz_1_1core_1_1string.html#a1d51094994baa05a0083222e4d588693">More...</a><br /></td></tr>
<tr class="separator:a1d51094994baa05a0083222e4d588693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfd03638c0920e1823da50ee80ed1f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aabfd03638c0920e1823da50ee80ed1f8">writeln</a> (<a class="el" href="classz_1_1core_1_1outputStream.html">outputStream</a> &amp;<a class="el" href="classz_1_1core_1_1stream.html">stream</a>, <a class="el" href="encoding_8hpp.html#abb9b3bdd67c870c617a43438ebb64c17">encoding</a> enc) const noexcept</td></tr>
<tr class="memdesc:aabfd03638c0920e1823da50ee80ed1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write string data to a stream, appending a newline.  <a href="classz_1_1core_1_1string.html#aabfd03638c0920e1823da50ee80ed1f8">More...</a><br /></td></tr>
<tr class="separator:aabfd03638c0920e1823da50ee80ed1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17986d29aa6a5ca77b6a8c9799ea8f36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a17986d29aa6a5ca77b6a8c9799ea8f36">writeln</a> (<a class="el" href="classz_1_1core_1_1outputStream.html">outputStream</a> &amp;<a class="el" href="classz_1_1core_1_1stream.html">stream</a>) const noexcept</td></tr>
<tr class="memdesc:a17986d29aa6a5ca77b6a8c9799ea8f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write string data to a stream in its format, appending a newline.  <a href="classz_1_1core_1_1string.html#a17986d29aa6a5ca77b6a8c9799ea8f36">More...</a><br /></td></tr>
<tr class="separator:a17986d29aa6a5ca77b6a8c9799ea8f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c526faeeb68245f9e0adb166484b34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1stringIterator.html">stringIterator</a>&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a44c526faeeb68245f9e0adb166484b34">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a44c526faeeb68245f9e0adb166484b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the beginning of the string.  <a href="classz_1_1core_1_1string.html#a44c526faeeb68245f9e0adb166484b34">More...</a><br /></td></tr>
<tr class="separator:a44c526faeeb68245f9e0adb166484b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2fc8826986292efa45ecba1bfa3014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1stringIterator.html">stringIterator</a>&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a4e2fc8826986292efa45ecba1bfa3014">end</a> () const noexcept</td></tr>
<tr class="memdesc:a4e2fc8826986292efa45ecba1bfa3014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the end of the string.  <a href="classz_1_1core_1_1string.html#a4e2fc8826986292efa45ecba1bfa3014">More...</a><br /></td></tr>
<tr class="separator:a4e2fc8826986292efa45ecba1bfa3014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0aafd2096bf8a78a6dd2bc834e1303"><td class="memTemplParams" colspan="2">template&lt;class archive &gt; </td></tr>
<tr class="memitem:a8e0aafd2096bf8a78a6dd2bc834e1303"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a8e0aafd2096bf8a78a6dd2bc834e1303">save_minimal</a> (archive &amp;ar) const</td></tr>
<tr class="memdesc:a8e0aafd2096bf8a78a6dd2bc834e1303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization output.  <a href="classz_1_1core_1_1string.html#a8e0aafd2096bf8a78a6dd2bc834e1303">More...</a><br /></td></tr>
<tr class="separator:a8e0aafd2096bf8a78a6dd2bc834e1303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260a3ab9868e371aedbe58d2aa157062"><td class="memTemplParams" colspan="2">template&lt;class archive &gt; </td></tr>
<tr class="memitem:a260a3ab9868e371aedbe58d2aa157062"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a260a3ab9868e371aedbe58d2aa157062">load_minimal</a> (archive const &amp;ar, std::string const &amp;value)</td></tr>
<tr class="memdesc:a260a3ab9868e371aedbe58d2aa157062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization input.  <a href="classz_1_1core_1_1string.html#a260a3ab9868e371aedbe58d2aa157062">More...</a><br /></td></tr>
<tr class="separator:a260a3ab9868e371aedbe58d2aa157062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classz_1_1core_1_1sizable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classz_1_1core_1_1sizable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classz_1_1core_1_1sizable.html">z::core::sizable</a></td></tr>
<tr class="memitem:a193dcadd32340117e6cf8372d294d252 inherit pub_methods_classz_1_1core_1_1sizable"><td class="memItemLeft" align="right" valign="top"><a id="a193dcadd32340117e6cf8372d294d252"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1sizable.html#a193dcadd32340117e6cf8372d294d252">~sizable</a> () noexcept</td></tr>
<tr class="memdesc:a193dcadd32340117e6cf8372d294d252 inherit pub_methods_classz_1_1core_1_1sizable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:a193dcadd32340117e6cf8372d294d252 inherit pub_methods_classz_1_1core_1_1sizable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1a394438ebafa86857838eeccb1b4718"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a1a394438ebafa86857838eeccb1b4718">operator&lt;&lt;</a> (std::ostream &amp;ostr, const <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt; &amp;str)</td></tr>
<tr class="memdesc:a1a394438ebafa86857838eeccb1b4718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream output operator.  <a href="classz_1_1core_1_1string.html#a1a394438ebafa86857838eeccb1b4718">More...</a><br /></td></tr>
<tr class="separator:a1a394438ebafa86857838eeccb1b4718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4787e5270acbff46efe5e88f1e63aaa1"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a4787e5270acbff46efe5e88f1e63aaa1">operator&gt;&gt;</a> (std::istream &amp;istr, <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt; &amp;str)</td></tr>
<tr class="memdesc:a4787e5270acbff46efe5e88f1e63aaa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream input operator.  <a href="classz_1_1core_1_1string.html#a4787e5270acbff46efe5e88f1e63aaa1">More...</a><br /></td></tr>
<tr class="separator:a4787e5270acbff46efe5e88f1e63aaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;encoding E = utf32&gt;<br />
class z::core::string&lt; E &gt;</h3>

<p>A template class for character strings. </p>
<p>This class focuses on how characters are encoded rather than character size. Possible encoding schemes are ASCII, UTF-8, UTF16, and UTF32.<br  />
 When characters are input or output, they are converted to or from their encoding scheme to a single UTF32 character. Thus, the "default" character type is <code>uint32_t</code>.</p>
<p>Note this class is compatible with standard library streams, but also has <a class="el" href="classz_1_1core_1_1string.html#a7c810e7dee8c31bc799293ed5f120b13" title="Read string data from a stream until the given delimiter is encountered.">read()</a>, <a class="el" href="classz_1_1core_1_1string.html#a197fec1700902dd7461f652fabceb7f0" title="Read string data from a stream until a newline is encountered.">readln()</a>, <a class="el" href="classz_1_1core_1_1string.html#acf6bcc21f5c030820f9a582d93cee747" title="Write string data to a stream.">write()</a>, <a class="el" href="classz_1_1core_1_1string.html#aabfd03638c0920e1823da50ee80ed1f8" title="Write string data to a stream, appending a newline.">writeln()</a> methods for interacting with <a class="el" href="classz_1_1core_1_1stream.html" title="An interface for character streams.">core::stream</a> objects (Useful if a specific encoding is strictly required).</p>
<p>To keep string types short, you may append _u32, _u16, _u8, or _asc after any literals. For example, here are a few different ways to construct a UTF32 encoded string: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> str1 = <span class="stringliteral">&quot;hello world&quot;</span>_u32;</div>
<div class="line"><span class="keyword">auto</span> str2 = L<span class="stringliteral">&quot;hello too!&quot;</span>_u32;</div>
<div class="line"><span class="keyword">auto</span> str3 = <span class="charliteral">&#39;X&#39;</span>_u32;</div>
<div class="line"><span class="keyword">auto</span> str4 = 1234_u32;</div>
</div><!-- fragment --><p> The above will all be of type z::core::string&lt;z::utf32&gt;</p>
<dl class="section note"><dt>Note</dt><dd>Allocated memory is increased as needed with approximate 1.5x growth, and is not decreased on subsequent data changes, except in the case where data is copied over to a different string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>encoding.h </dd>
<dd>
zstr.h </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3dac1aad193774be2919f3c7e8e9666b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dac1aad193774be2919f3c7e8e9666b">&#9670;&nbsp;</a></span>string() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>chr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct string from a single-byte character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chr</td><td>Initializing character.</td></tr>
  </table>
  </dd>
</dl>
<p>Character is assumed to be compatible with this string's encoding. </p>

</div>
</div>
<a id="aceb6bd9a9a9447b23d3fb804586b8880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb6bd9a9a9447b23d3fb804586b8880">&#9670;&nbsp;</a></span>string() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">wchar_t&#160;</td>
          <td class="paramname"><em>chr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct string from a wide character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chr</td><td>Initializing character.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts the given character to the appropriate encoding for this string. </p>

</div>
</div>
<a id="a6987eedf472fa0b1f5f32cb4dfa16141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6987eedf472fa0b1f5f32cb4dfa16141">&#9670;&nbsp;</a></span>string() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>chr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct string from uint32_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chr</td><td>Initializing character.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor exists to allow a "default" string character to again be constructed into a string. Converts the given character to the appropriate encoding for this string. </p>

</div>
</div>
<a id="a1a85952a47b96150a7f3f540535bdd25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a85952a47b96150a7f3f540535bdd25">&#9670;&nbsp;</a></span>string() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a cstring of single-byte characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Null-terminated cstring.</td></tr>
  </table>
  </dd>
</dl>
<p>All characters are assumed to be compatible with this string's encoding. </p>

</div>
</div>
<a id="aee9e76587629cc1cc42435c1646ef424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9e76587629cc1cc42435c1646ef424">&#9670;&nbsp;</a></span>string() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a cstring of wide characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Null-terminated cstring.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts the characters in the given cstring to the appropriate encoding for this string. </p>

</div>
</div>
<a id="a24cd477dde33d3272f9780cec18297ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cd477dde33d3272f9780cec18297ef">&#9670;&nbsp;</a></span>string() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<div class="memtemplate">
template&lt;typename INT , typename  = typename std::enable_if&lt;				std::is_integral&lt;INT&gt;::value &amp;&amp; !std::is_same&lt;INT,char&gt;::value &amp;&amp; !std::is_same&lt;INT,wchar_t&gt;::value				,INT&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>padSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from an integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An integer. </td></tr>
    <tr><td class="paramname">base</td><td>The number's base. </td></tr>
    <tr><td class="paramname">padSize</td><td>Number of characters to pad up to.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts an integer to a string in the given base. If the character count is less than the pad size, zeroes are added to the left side until the character count equals the pad size. Valid base sizes are from 2 to 36, and anything else is assumed to be base 10. If the pad size is less than 1, no character padding is applied. </p>

</div>
</div>
<a id="ab8bed0f235b563c4c200bcb7a24f6374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8bed0f235b563c4c200bcb7a24f6374">&#9670;&nbsp;</a></span>string() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<div class="memtemplate">
template&lt;typename PTR , typename  = typename std::enable_if&lt;				std::is_pointer&lt;PTR&gt;::value &amp;&amp; !std::is_same&lt;PTR,char*&gt;::value &amp;&amp; !std::is_same&lt;PTR,wchar_t*&gt;::value				,PTR&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">PTR&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>A pointer.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates a string representation from a pointer, of the form <code>0xFFFFFFFF</code>. If <code>Z_STR_POINTER_FORCE</code> is defined as <code>true</code>, then the hex part of the string is padded up to <code>Z_STR_POINTER_CHARS</code> characters (default is 8). </p>

</div>
</div>
<a id="a884576fbd00bc546b858771288041d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884576fbd00bc546b858771288041d42">&#9670;&nbsp;</a></span>string() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<div class="memtemplate">
template&lt;typename FLT , typename  = typename std::enable_if&lt;std::is_floating_point&lt;FLT&gt;::value,FLT&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">FLT&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>padSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from floating-point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A floating-point number. </td></tr>
    <tr><td class="paramname">base</td><td>The number's base. </td></tr>
    <tr><td class="paramname">precision</td><td>The number of characters after the decimal point. </td></tr>
    <tr><td class="paramname">scientific</td><td>Whether to use scientific notation. </td></tr>
    <tr><td class="paramname">padSize</td><td>Number of characters to pad up to.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts a floating-point number to a string in the given base. If the character count is less than the pad size, zeroes are added to the left side until the character count equals the pad size. Valid base sizes are from 2 to 36, and anything else is assumed to be base 10. If the pad size is less than 1, no character padding is applied. If the precision is 1 or greater, then exactly that many digits will show after the decimal point, otherwise up to <code>Z_STR_FLOAT_PRECISION</code> digits will show (default is 6). </p>

</div>
</div>
<a id="a0271bd586225ca6a9a0492ed66b4ae82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0271bd586225ca6a9a0492ed66b4ae82">&#9670;&nbsp;</a></span>string() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value,T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>padSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A floating-point complex number. </td></tr>
    <tr><td class="paramname">base</td><td>The number's base. </td></tr>
    <tr><td class="paramname">precision</td><td>The number of characters after the decimal point. </td></tr>
    <tr><td class="paramname">scientific</td><td>Whether to use scientific notation. </td></tr>
    <tr><td class="paramname">padSize</td><td>Number of characters to pad up to.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts a floating-point complex number to a string in the given base. This string will look like <code>X+Yi</code>, <code>X-Yi</code>, <code>-X+Yi</code>, or <code>-X-Yi</code>. Valid base sizes are from 2 to 36, and anything else is assumed to be base 10. If the precision is 1 or greater, then exactly that many digits will show after the decimal point, otherwise up to <code>Z_STR_FLOAT_PRECISION</code> digits will show (default is 6). </p>

</div>
</div>
<a id="a2a1d79e87ce3f2c0a5d92a97c598216f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1d79e87ce3f2c0a5d92a97c598216f">&#9670;&nbsp;</a></span>string() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; ascii &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from an ASCII string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>An ASCII encoded string.</td></tr>
  </table>
  </dd>
</dl>
<p>Copies over characters from the given string, converting them to the appropriate encoding scheme for this string. </p>

</div>
</div>
<a id="a8ec23d43fa2edf50af7e1a08a272173b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec23d43fa2edf50af7e1a08a272173b">&#9670;&nbsp;</a></span>string() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; utf8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a UTF-8 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A UTF-8 encoded string.</td></tr>
  </table>
  </dd>
</dl>
<p>Copies over characters from the given string, converting them to the appropriate encoding scheme for this string. </p>

</div>
</div>
<a id="a78e0a419764c155d24f17d6b76239909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e0a419764c155d24f17d6b76239909">&#9670;&nbsp;</a></span>string() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; utf16 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a UTF16 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A UTF16 encoded string.</td></tr>
  </table>
  </dd>
</dl>
<p>Copies over characters from the given string, converting them to the appropriate encoding scheme for this string. </p>

</div>
</div>
<a id="a5858ead5f3e043184af3ae731d87ad85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5858ead5f3e043184af3ae731d87ad85">&#9670;&nbsp;</a></span>string() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; utf32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a UTF32 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A UTF32 encoded string.</td></tr>
  </table>
  </dd>
</dl>
<p>Copies over characters from the given string, converting them to the appropriate encoding scheme for this string. </p>

</div>
</div>
<a id="ae874c9d0a4107c1891b91218068266cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae874c9d0a4107c1891b91218068266cd">&#9670;&nbsp;</a></span>string() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Moves a string of the same encoding. Just does a mem copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a01a7f895948b49fcc302bc12d8c7f52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a7f895948b49fcc302bc12d8c7f52b">&#9670;&nbsp;</a></span>append() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append another string to the end of this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the other string is appended.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a3fefb79339db522571cc239cadf31020" title="Append another string to the end of this one.">operator+=()</a> </dd></dl>

</div>
</div>
<a id="ac189b8ddeb0f81b7921a7b870083c0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac189b8ddeb0f81b7921a7b870083c0eb">&#9670;&nbsp;</a></span>append() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::append </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a single character to the end of the string. </p>
<p>Use this method if you need to append raw characters (i.e. they're coming from a stream), as it is more efficient than first casting the character to a string and appending that way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chr</td><td>The character to append, in UTF32 format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the character is appended.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a3fefb79339db522571cc239cadf31020" title="Append another string to the end of this one.">operator+=()</a> </dd></dl>

</div>
</div>
<a id="a037e988d7f9349740b59d0d74ff22aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037e988d7f9349740b59d0d74ff22aeb">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the character at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the character to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character at the given index, in UTF32 format.</dd></dl>
<p>If the index is greater than the character count, the null character is returned. For UTF-8 strings, if the chracter at the given index is part of a multibyte sequence, that sequence is converted to UTF32 and returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#aee85973dffb32fc45cfb1080f0e7ecd6" title="Get the character at the given index.">operator[]()</a> </dd></dl>

</div>
</div>
<a id="a44c526faeeb68245f9e0adb166484b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c526faeeb68245f9e0adb166484b34">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1stringIterator.html">stringIterator</a>&lt;E&gt; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator for the beginning of the string. </p>
<p>This member function should not be used directly. It is meant for C++11's range-based for loop syntax.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator on the first character in the string. </dd></dl>

</div>
</div>
<a id="abc1371419b27c739ff80f47661fd4c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1371419b27c739ff80f47661fd4c17">&#9670;&nbsp;</a></span>beginsWith()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::beginsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the string begins with a given sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to check for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this string begins with the given sub-string. False otherwise. </dd></dl>

</div>
</div>
<a id="a4f6b4c3254762941ab789251f7f57836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6b4c3254762941ab789251f7f57836">&#9670;&nbsp;</a></span>camel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::camel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a camelcase version of this string. </p>
<dl class="section return"><dt>Returns</dt><dd>A duplicate of this string, converted to camelcase. </dd></dl>

</div>
</div>
<a id="adb98c8ecf3aa9a78a59d88cf2a94c7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb98c8ecf3aa9a78a59d88cf2a94c7bc">&#9670;&nbsp;</a></span>chars()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::chars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the individual character count of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of characters in the string.</dd></dl>
<p>For UTF-8 strings, multibyte sequences are counted as a single character.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a09c25e8c1e48ddb23e1d67327811f645" title="Get the character count of the string.">length()</a> </dd></dl>

</div>
</div>
<a id="aec7ee171c8c23c2de9b8e691c557b9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7ee171c8c23c2de9b8e691c557b9da">&#9670;&nbsp;</a></span>complex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;double&gt; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::complex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>decimal</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert this string to a complex value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base this string is being interpreted as. </td></tr>
    <tr><td class="paramname">decimal</td><td>The character used to denote the radix (decimal place).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The floating-point complex representation of this string, if it is a valid complex float. 0 otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a70f2edc11684860b5741f614d0ddf384" title="Check if this string can convert to a complex value.">isComplex()</a> </dd></dl>

</div>
</div>
<a id="ad5b6fca4c36928c63442bd66738afde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b6fca4c36928c63442bd66738afde6">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; const std::pair&lt; uint32_t, uint32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this string contains any characters in the given ranges. </p>
<p>example: this-&gt;contains({{'A', 'Z'}, {'a', 'z'}, {'0', '9'}}) will return true if this string contains an alphanumeric character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list of std::pair objects denoting all valid character ranges. </td></tr>
    <tr><td class="paramname">exclusive</td><td>Return false if this string contains any characters NOT in any of the given ranges.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether this string contained a character in any of the given ranges, or if the <code>exclusive</code> flag is set, whether it contains ONLY characters in the given ranges. </dd></dl>

</div>
</div>
<a id="a47eb35c738fc945653b681f9ad833289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47eb35c738fc945653b681f9ad833289">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; uint32_t, uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this string contains any characters in the given range. </p>
<p>example: this-&gt;contains({'A', 'Z'}) will return true if this string contains a character in the range A -&gt; Z, inclusive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>A std::pair denoting the character range. </td></tr>
    <tr><td class="paramname">exclusive</td><td>Return false if this string contains any characters NOT in the given string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether this string contained a character in the given range, or if the <code>exclusive</code> flag is set, whether it contains ONLY characters in the given range. </dd></dl>

</div>
</div>
<a id="af9fad872ff436d306447bdb8fbda5650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fad872ff436d306447bdb8fbda5650">&#9670;&nbsp;</a></span>contains() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this string contains any of the characters in the given string. </p>
<p>example: this-&gt;contains("aeiouyAEIOUY") will return true if this contains a vowel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A string indicating the list of valid characters. </td></tr>
    <tr><td class="paramname">exclusive</td><td>Return false if this string contains any characters NOT in the given string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether this string contained any of the characters in the given string, or if the <code>exclusive</code> flag is set, whether it contains ONLY characters in the given string. </dd></dl>

</div>
</div>
<a id="a681fe4167410b67fc551ba110ab05caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681fe4167410b67fc551ba110ab05caf">&#9670;&nbsp;</a></span>contains() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this string contains any characters in the given range. </p>
<p>example: this-&gt;contains('A', 'Z') will return true if this string contains a character in the range A -&gt; Z, inclusive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first character in the range. </td></tr>
    <tr><td class="paramname">last</td><td>The last character in the range. </td></tr>
    <tr><td class="paramname">exclusive</td><td>Return false if this string contains any characters NOT in the given string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether this string contained a character in the given range, or if the <code>exclusive</code> flag is set, whether it contains ONLY characters in the given range. </dd></dl>

</div>
</div>
<a id="a12b0f9f2dc434e125a09f9d0b41b4d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b0f9f2dc434e125a09f9d0b41b4d06">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the occurrences of a sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of times the given sub-string appears in the full string. </dd></dl>

</div>
</div>
<a id="ac5954e333c390718fe085e930bbf7317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5954e333c390718fe085e930bbf7317">&#9670;&nbsp;</a></span>cstring()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::cstring </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the single-byte cstring pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the string data, if this string is in a single-byte format. <code>NULL</code> otherwise. </dd></dl>

</div>
</div>
<a id="a32c9f412dbc1c8a30695c8accb169ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c9f412dbc1c8a30695c8accb169ba4">&#9670;&nbsp;</a></span>cutDuplicates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::cutDuplicates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all sequential duplicates from this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to remove duplicates of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after removing duplicates.</dd></dl>
<p>Removes all contiguous repetitions of the given sub-string, leaving one instance of the sub-string where the group was. </p>

</div>
</div>
<a id="a4e2fc8826986292efa45ecba1bfa3014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2fc8826986292efa45ecba1bfa3014">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1stringIterator.html">stringIterator</a>&lt;E&gt; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator for the end of the string. </p>
<p>This member function should not be used directly. It is meant for C++11's range-based for loop syntax.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator after the last character in the string. </dd></dl>

</div>
</div>
<a id="a410f2a23a73f84f5f3c0194587a57697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410f2a23a73f84f5f3c0194587a57697">&#9670;&nbsp;</a></span>endsWith()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::endsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the string ends with a given sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to check for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this string ends with the given sub-string. False otherwise. </dd></dl>

</div>
</div>
<a id="a1c5e1fa34df91b2188d72e69e362344c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5e1fa34df91b2188d72e69e362344c">&#9670;&nbsp;</a></span>filter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; const std::pair&lt; uint32_t, uint32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filter out all characters not in the given range. </p>
<p>example: this-&gt;filter({{'A', 'Z'}, {'a', 'z'}, {'0', '9'}}) will remove all characters that are not alphanumeric.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list of std::pair objects denoting all valid character ranges. </td></tr>
    <tr><td class="paramname">invert</td><td>Invert the selection, that is, remove all characters that <b>ARE</b> in the given range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A duplicate of this string with all non-matching characters removed. </dd></dl>

</div>
</div>
<a id="a3926b94769d52b94e3abc8ec728c2335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3926b94769d52b94e3abc8ec728c2335">&#9670;&nbsp;</a></span>filter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; uint32_t, uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filter out all characters not in the given range. </p>
<p>example: this-&gt;filter({'A', 'Z'}) will remove all characters not in the range A -&gt; Z, inclusive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>A std::pair denoting the character range. </td></tr>
    <tr><td class="paramname">invert</td><td>Invert the selection, that is, remove all characters that <b>ARE</b> in the given range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A duplicate of this string with all non-matching characters removed. </dd></dl>

</div>
</div>
<a id="a06d1fdfec88d9dda0dc1766d6bba7c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d1fdfec88d9dda0dc1766d6bba7c7b">&#9670;&nbsp;</a></span>filter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filter out all characters not in the given string. </p>
<p>example: this-&gt;filter("aeiouyAEIOUY") will remove all non-vowel characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A string indicating the list of valid characters. </td></tr>
    <tr><td class="paramname">invert</td><td>Invert the selection, that is, remove all characters that <b>ARE</b> in the given range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A duplicate of this string with all non-matching characters removed. </dd></dl>

</div>
</div>
<a id="a45fd0f663f22e02dbcdabb6e12a12285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45fd0f663f22e02dbcdabb6e12a12285">&#9670;&nbsp;</a></span>filter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filter out all characters not in the given range. </p>
<p>example: this-&gt;filter('A', 'Z') will remove all characters not in the range A -&gt; Z, inclusive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first character in the range. </td></tr>
    <tr><td class="paramname">last</td><td>The last character in the range. </td></tr>
    <tr><td class="paramname">invert</td><td>Invert the selection, that is, remove all characters that <b>ARE</b> in the given range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A duplicate of this string with all non-matching characters removed. </dd></dl>

</div>
</div>
<a id="a17f3b6f5a58ea7e8857a5bc19ac9e248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f3b6f5a58ea7e8857a5bc19ac9e248">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a specific occurrence of a sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to search for. </td></tr>
    <tr><td class="paramname">occurrence</td><td>The occurrence of the sub-string to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the given occurrence of the sub-string, if that occurrence was found. Otherwise, -1.</dd></dl>
<p>Attempts to find given occurrence of the sub-string starting at the <b>beginning</b> of the string. Note that the occurrence starts at 1. If the occurrence is less than 1, then -1 is returned. </p>

</div>
</div>
<a id="a9d2f2d957cc32c166bfb80b3b701ee08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2f2d957cc32c166bfb80b3b701ee08">&#9670;&nbsp;</a></span>findAfter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::findAfter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a specific occurrence of a sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to search for. </td></tr>
    <tr><td class="paramname">index</td><td>The index to start at. </td></tr>
    <tr><td class="paramname">occurrence</td><td>The occurrence of the sub-string to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the given occurrence of the sub-string, if that occurrence was found. Otherwise, -1.</dd></dl>
<p>Attempts to find given occurrence of the sub-string, searching forward starting at the given index. Note that the occurrence starts at 1. If the occurrence is less than 1, then -1 is returned. </p>

</div>
</div>
<a id="aa9c542fcf7f12913c2d3af154c300c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c542fcf7f12913c2d3af154c300c28">&#9670;&nbsp;</a></span>findBefore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::findBefore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse-find a specific occurrence of a sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to search for. </td></tr>
    <tr><td class="paramname">index</td><td>The index to start at. </td></tr>
    <tr><td class="paramname">occurrence</td><td>The occurrence of the sub-string to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the given occurrence of the sub-string, if that occurrence was found. Otherwise, -1.</dd></dl>
<p>Attempts to find given occurrence of the sub-string, searching backward starting at the given index. Note that the occurrence starts at 1. If the occurrence is less than 1, then -1 is returned. </p>

</div>
</div>
<a id="a515118a25d1706ee8e91754c30d55218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515118a25d1706ee8e91754c30d55218">&#9670;&nbsp;</a></span>findLast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::findLast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse-find a specific occurrence of a sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to search for. </td></tr>
    <tr><td class="paramname">occurrence</td><td>The occurrence of the sub-string to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the given occurrence of the sub-string, if that occurrence was found. Otherwise, -1.</dd></dl>
<p>Attempts to find given occurrence of the sub-string starting at the <b>end</b> of the string. Note that the occurrence starts at 1. If the occurrence is less than 1, then -1 is returned. </p>

</div>
</div>
<a id="a3d27dfd8e5df8288d8859c087fe67cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d27dfd8e5df8288d8859c087fe67cc1">&#9670;&nbsp;</a></span>floating()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::floating </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>decimal</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert this string to a floating-point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base this string is being interpreted as. </td></tr>
    <tr><td class="paramname">decimal</td><td>The character used to denote the radix (decimal place).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The floating-point representation of this string, if it is a valid float. 0 otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#afe1cd83fd6ca82ac6f2a9e92562804a0" title="Check if this string can convert to a floating-point value.">isFloating()</a> </dd></dl>

</div>
</div>
<a id="af080f57c9f262b48e15e7d85d500e3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af080f57c9f262b48e15e7d85d500e3f8">&#9670;&nbsp;</a></span>format()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="encoding_8hpp.html#abb9b3bdd67c870c617a43438ebb64c17">encoding</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::format </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the encoding of this string. </p>
<dl class="section return"><dt>Returns</dt><dd>An integer indicating this string's encoding.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>encoding.h </dd></dl>

</div>
</div>
<a id="ad88d54285e20d23be6bb69edfef9ebbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88d54285e20d23be6bb69edfef9ebbc">&#9670;&nbsp;</a></span>foundAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::foundAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a sub-string is found at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to check for. </td></tr>
    <tr><td class="paramname">index</td><td>The index in the string to look at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sub-string was found beginning at the given index. False otherwise. </dd></dl>

</div>
</div>
<a id="a2e23641e0457fa6c3b371e6b5d5e30dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e23641e0457fa6c3b371e6b5d5e30dc">&#9670;&nbsp;</a></span>foundEndAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::foundEndAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a sub-string ends at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to check for. </td></tr>
    <tr><td class="paramname">index</td><td>The index in the string to look at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sub-string was found ending at the given index. False otherwise. </dd></dl>

</div>
</div>
<a id="ac428c7c81a4b4b76cfa8b68eafa00076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac428c7c81a4b4b76cfa8b68eafa00076">&#9670;&nbsp;</a></span>increase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::increase </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>charCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the space allocated for this string. </p>
<p>If this string currently has fewer than max_chars allocated, enough space is reallocated to hold at least that many characters. Note that strings follow an approximate 1.5x growth pattern.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">charCount</td><td>The minimum number of characters this string should be able to contain before reallocating. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3314be548e8d54690b8c6de47b7e7bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3314be548e8d54690b8c6de47b7e7bcb">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert another string into this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to insert. </td></tr>
    <tr><td class="paramname">index</td><td>The index to insert before.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the other string is inserted.</dd></dl>
<p>Inserts the given string before the given index. So, for <code>B = "abc"</code> and <code>A = "xyz"</code>, <code>A.insert(B,0)</code> would give <code>"abcxyz"</code>, <code>A.insert(B,1)</code> would give <code>"xabcyz"</code>, etc. </p>

</div>
</div>
<a id="a41ea919808135fd2ac1e19231e6eb94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ea919808135fd2ac1e19231e6eb94a">&#9670;&nbsp;</a></span>integer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::integer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>decimal</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert this string to an integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base this string is being interpreted as. </td></tr>
    <tr><td class="paramname">decimal</td><td>The character used to denote the radix (decimal place).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A signed integer representation of this string, if it is a valid integer. 0 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If a radix character is encountered before any invalid characters, any text following the radix is ignored.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a010ccdee32ca8973fee25eaeab2e64dc" title="Check if this string can convert to an integer.">isInteger()</a> </dd></dl>

</div>
</div>
<a id="a70f2edc11684860b5741f614d0ddf384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f2edc11684860b5741f614d0ddf384">&#9670;&nbsp;</a></span>isComplex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::isComplex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>decimal</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this string can convert to a complex value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base this string is being interpreted as. </td></tr>
    <tr><td class="paramname">decimal</td><td>The character that is used as a decimal separator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the string contains only characters representing a floating-point complex number. False otherwise.</dd></dl>
<p>Valid strings must follow the form <code>X+Yi</code> or <code>Xi+Y</code>, where <code>X</code> and <code>Y</code> are floating-point values. <code>X</code> may optionally have a <code>+</code> or <code>-</code> preceding it, and <code>Y</code> may be preceded by a <code>-</code> instead of a <code>+</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#afe1cd83fd6ca82ac6f2a9e92562804a0" title="Check if this string can convert to a floating-point value.">isFloating()</a> </dd>
<dd>
<a class="el" href="classz_1_1core_1_1string.html#aec7ee171c8c23c2de9b8e691c557b9da" title="Convert this string to a complex value.">complex()</a> </dd></dl>

</div>
</div>
<a id="afe1cd83fd6ca82ac6f2a9e92562804a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1cd83fd6ca82ac6f2a9e92562804a0">&#9670;&nbsp;</a></span>isFloating()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::isFloating </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>decimal</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this string can convert to a floating-point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base this string is being interpreted as. </td></tr>
    <tr><td class="paramname">decimal</td><td>The character that is used as a decimal separator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the string contains only characters representing a float. False otherwise.</dd></dl>
<p>Valid strings may optionally begin with a <code>+</code> or <code>-</code>, and contain only one period (decimal point). The number may also have an exponent in the same base, in the form <code>XXeY</code>, where the exponent <code>Y</code> may optionally begin with a <code>+</code> or <code>-</code>. Unlike the main number, this exponent must be an integer.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a3d27dfd8e5df8288d8859c087fe67cc1" title="Convert this string to a floating-point value.">floating()</a> </dd></dl>

</div>
</div>
<a id="a010ccdee32ca8973fee25eaeab2e64dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010ccdee32ca8973fee25eaeab2e64dc">&#9670;&nbsp;</a></span>isInteger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::isInteger </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this string can convert to an integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base this string is being interpreted as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the string contains only characters representing a signed integer. False otherwise.</dd></dl>
<p>Valid strings may contain only numeric characters in the given base, and may optionally begin with a <code>+</code> or <code>-</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a41ea919808135fd2ac1e19231e6eb94a" title="Convert this string to an integer.">integer()</a> </dd></dl>

</div>
</div>
<a id="a09c25e8c1e48ddb23e1d67327811f645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c25e8c1e48ddb23e1d67327811f645">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the character count of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of characters in the string.</dd></dl>
<p>For UTF-8 strings, multibyte sequences are counted as multiple characters.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#adb98c8ecf3aa9a78a59d88cf2a94c7bc" title="Get the individual character count of the string.">chars()</a> </dd></dl>

</div>
</div>
<a id="a260a3ab9868e371aedbe58d2aa157062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260a3ab9868e371aedbe58d2aa157062">&#9670;&nbsp;</a></span>load_minimal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<div class="memtemplate">
template&lt;class archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::load_minimal </td>
          <td>(</td>
          <td class="paramtype">archive const &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&lt; E &gt; const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar</td><td>The input archive. </td></tr>
    <tr><td class="paramname">value</td><td>The string to input from serial archive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a1628e28d262fc80c69e89473500c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1628e28d262fc80c69e89473500c93">&#9670;&nbsp;</a></span>lower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::lower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a lowercase version of this string. </p>
<dl class="section return"><dt>Returns</dt><dd>A duplicate of this string, converted to lowercase. </dd></dl>

</div>
</div>
<a id="ac99b04cc2a3751516f49cb654d213356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99b04cc2a3751516f49cb654d213356">&#9670;&nbsp;</a></span>nstring()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t* <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::nstring </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the two-byte cstring pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the string data, if this string is in a two-byte format. <code>NULL</code> otherwise. </dd></dl>

</div>
</div>
<a id="acfe2be987f0a6972683f1b84b2fc0754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe2be987f0a6972683f1b84b2fc0754">&#9670;&nbsp;</a></span>operator double()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator double </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert this string to a floating-point value. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a3d27dfd8e5df8288d8859c087fe67cc1" title="Convert this string to a floating-point value.">floating()</a> </dd></dl>

</div>
</div>
<a id="a04d8e2bc02221468f5526f5739b0ec9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d8e2bc02221468f5526f5739b0ec9d">&#9670;&nbsp;</a></span>operator float()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator float </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert this string to a floating-point value. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a3d27dfd8e5df8288d8859c087fe67cc1" title="Convert this string to a floating-point value.">floating()</a> </dd></dl>

</div>
</div>
<a id="afe8b8c3e5d8cf56e10ea6ef2f19f8acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8b8c3e5d8cf56e10ea6ef2f19f8acc">&#9670;&nbsp;</a></span>operator INT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<div class="memtemplate">
template&lt;typename INT , typename  = typename std::enable_if&lt;std::is_integral&lt;INT&gt;::value,INT&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator INT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert this string to an integer. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a41ea919808135fd2ac1e19231e6eb94a" title="Convert this string to an integer.">integer()</a> </dd></dl>

</div>
</div>
<a id="a19e986e795ba9985a3faff3d56cf300e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e986e795ba9985a3faff3d56cf300e">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the strings do not exactly match. False otherwise. </dd></dl>

</div>
</div>
<a id="a27ea52347a2d0a44dad9e0cccda1449f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ea52347a2d0a44dad9e0cccda1449f">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate two strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of this and the given string.</dd></dl>
<p>Appends the given string to the end of this string's characters and returns the result. This string is not modified. </p>

</div>
</div>
<a id="a3fefb79339db522571cc239cadf31020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fefb79339db522571cc239cadf31020">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append another string to the end of this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the other string is appended.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a01a7f895948b49fcc302bc12d8c7f52b" title="Append another string to the end of this one.">append()</a> </dd></dl>

</div>
</div>
<a id="aac2d440a910caf4f4bc2b8d6e503ea0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2d440a910caf4f4bc2b8d6e503ea0a">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this string comes before the given string alphabetically. False otherwise. </dd></dl>

</div>
</div>
<a id="ac882ad90bd12339c690e2978a06e1ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac882ad90bd12339c690e2978a06e1ed4">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than or equal comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this string does not come after the given string alphabetically. False otherwise. </dd></dl>

</div>
</div>
<a id="a75b5be8cdb78daa62baad1c0786a7530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b5be8cdb78daa62baad1c0786a7530">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the contents of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after assignment.</dd></dl>
<p>Copies all characters from the given string over to this string, replacing current data. </p>

</div>
</div>
<a id="a0ed3abe80b423c9e0cf3a1c40ef70733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed3abe80b423c9e0cf3a1c40ef70733">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<p>Moves a string of the same encoding. Since this string has already been allocated data, we must first deallocate, then do a mem copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeae8fdb335a58f12e3c5583fbcb053c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae8fdb335a58f12e3c5583fbcb053c9">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the strings exactly match. False otherwise. </dd></dl>

</div>
</div>
<a id="a52b71a49ce01ad6de4b49d7fb8f90f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b71a49ce01ad6de4b49d7fb8f90f6f">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this string comes after the given string alphabetically. False otherwise. </dd></dl>

</div>
</div>
<a id="a27ab0b269111dc5a51da7583d1da9358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ab0b269111dc5a51da7583d1da9358">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than or equal comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this string does not come before the given string alphabetically. False otherwise. </dd></dl>

</div>
</div>
<a id="aee85973dffb32fc45cfb1080f0e7ecd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee85973dffb32fc45cfb1080f0e7ecd6">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the character at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the character to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character at the given index, in UTF32 format.</dd></dl>
<p>If the index is greater than the character count, the null character is returned. For UTF-8 strings, if the chracter at the given index is part of a multibyte sequence, that sequence is converted to UTF32 and returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a037e988d7f9349740b59d0d74ff22aeb" title="Get the character at the given index.">at()</a> </dd></dl>

</div>
</div>
<a id="a2005c7a79afc14b62ac9db2f771b82bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2005c7a79afc14b62ac9db2f771b82bf">&#9670;&nbsp;</a></span>padLeft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::padLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>padSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy this string, left-padded given character count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to pad on the left of the string. </td></tr>
    <tr><td class="paramname">padSize</td><td>the number of characters to pad up to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of this string after padding.</dd></dl>
<p>If the given string contains more than one character, then some of that string's characters may be cut off in the resultant string. If the pad size is equal or less than the current chracter count, then no padding will be added. </p>

</div>
</div>
<a id="ae8a9196e39c9db62eace90b131fb4672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a9196e39c9db62eace90b131fb4672">&#9670;&nbsp;</a></span>padLeftIn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::padLeftIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>padSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left-pad this string up to a given character count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to pad on the left of this string. </td></tr>
    <tr><td class="paramname">padSize</td><td>the number of characters to pad up to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after padding.</dd></dl>
<p>If the given string contains more than one character, then some of that string's characters may be cut off in the resultant string. If the pad size is equal or less than the current chracter count, then no padding will be added. </p>

</div>
</div>
<a id="a4177775bd189938a963d902bb41d6520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4177775bd189938a963d902bb41d6520">&#9670;&nbsp;</a></span>padRight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::padRight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>padSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy this string, right-padded given character count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to pad on the right of the string. </td></tr>
    <tr><td class="paramname">padSize</td><td>the number of characters to pad up to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of this string after padding.</dd></dl>
<p>If the given string contains more than one character, then some of that string's characters may be cut off in the resultant string. If the pad size is equal or less than the current chracter count, then no padding will be added. </p>

</div>
</div>
<a id="a3150636a59c7307ecea99d10a6b1f034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3150636a59c7307ecea99d10a6b1f034">&#9670;&nbsp;</a></span>padRightIn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::padRightIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>padSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right-pad this string up to a given character count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to pad on the right of this string. </td></tr>
    <tr><td class="paramname">padSize</td><td>the number of characters to pad up to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after padding.</dd></dl>
<p>If the given string contains more than one character, then some of that string's characters may be cut off in the resultant string. If the pad size is equal or less than the current chracter count, then no padding will be added. </p>

</div>
</div>
<a id="a7c810e7dee8c31bc799293ed5f120b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c810e7dee8c31bc799293ed5f120b13">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classz_1_1core_1_1inputStream.html">inputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read string data from a stream until the given delimiter is encountered. </p>
<p>Reads until the delimiting character is encountered, or the stream is exhausted. If the delimiter is 0 or not given, the delimiter is assumed to be any white space character. Leading delimiter characters are skipped over until a non-delimiter character is encountered or the stream is exhausted. Any data this string contains is wiped when this function is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to read from. </td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter to read until.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after reading. </dd></dl>

</div>
</div>
<a id="a197fec1700902dd7461f652fabceb7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197fec1700902dd7461f652fabceb7f0">&#9670;&nbsp;</a></span>readln()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::readln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classz_1_1core_1_1inputStream.html">inputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read string data from a stream until a newline is encountered. </p>
<p>Reads until a newline is encountered (either <code>\r\n</code> or <code>\n</code>), or the stream is exhausted. Leading newlines are not skipped, so as to allow for empty lines. Any data this string contains is wiped when this function is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after reading the line. </dd></dl>

</div>
</div>
<a id="a4859c295acebf35c40a892af33ef4a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4859c295acebf35c40a892af33ef4a65">&#9670;&nbsp;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove occurrences of the given sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to remove. </td></tr>
    <tr><td class="paramname">occurrence</td><td>The occurrence to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the sub-string is removed.</dd></dl>
<p>If the occurrence is 0, all occurrences of the sub-string are removed. If the occurrence is negative, then none are removed. Otherwise, only the specified occurrence of the sub-string is removed from the main string, starting from the beginning. </p>

</div>
</div>
<a id="ac1f96aebbcd4cd47a3f407967900064c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f96aebbcd4cd47a3f407967900064c">&#9670;&nbsp;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a subset of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The starting index. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the characters are removed.</dd></dl>
<p>If count is 0, no characters are removed. If count is negative, characters are removed in reverse order. </p>

</div>
</div>
<a id="aac3d553c79a0a897becf916d6d2c5469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3d553c79a0a897becf916d6d2c5469">&#9670;&nbsp;</a></span>repeat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::repeat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repeat this string a specific number of times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of times to repeat this string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resultant string. </dd></dl>

</div>
</div>
<a id="a5d961c716fd579f8c166a9fc662752c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d961c716fd579f8c166a9fc662752c1">&#9670;&nbsp;</a></span>replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>findStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>replStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace occurrences of the given sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">findStr</td><td>The sub-string to replace. </td></tr>
    <tr><td class="paramname">replStr</td><td>The string to replace the sub-string with. </td></tr>
    <tr><td class="paramname">occurrence</td><td>The occurrence to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the sub-string is replaced.</dd></dl>
<p>If the occurrence is 0, all occurrences of the sub-string are replaced. If the occurrence is negative, then none are replaced. Otherwise, only the specified occurrence of the sub-string is replaced, starting from the beginning of this string. </p>

</div>
</div>
<a id="a0112c15e36a180f3719f21db0cd0b9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0112c15e36a180f3719f21db0cd0b9d6">&#9670;&nbsp;</a></span>replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace a subset of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The starting index. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to remove. </td></tr>
    <tr><td class="paramname">other</td><td>The string to replace the subset with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the characters are replaced.</dd></dl>
<p>If count is 0, no characters are replaced. Characters are replaced in forward-order whether count is positive or negative. </p>

</div>
</div>
<a id="a8e0aafd2096bf8a78a6dd2bc834e1303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0aafd2096bf8a78a6dd2bc834e1303">&#9670;&nbsp;</a></span>save_minimal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<div class="memtemplate">
template&lt;class archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::save_minimal </td>
          <td>(</td>
          <td class="paramtype">archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar</td><td>The output archive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string to output to serial archive. </dd></dl>

</div>
</div>
<a id="a961659a5ec0b38a0c48ff2ed6f0c2f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961659a5ec0b38a0c48ff2ed6f0c2f56">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the string in memory. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in memory this string currently consumes. </dd></dl>

<p>Implements <a class="el" href="classz_1_1core_1_1sizable.html#ad97c4d0fa6e63e9934c0a76e816ec7d7">z::core::sizable</a>.</p>

</div>
</div>
<a id="aaa571037a910a6408277e5d823a15fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa571037a910a6408277e5d823a15fa8">&#9670;&nbsp;</a></span>substr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a sub-string from this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The sub-string starting index. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters in the sub-string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A subset of the original string.</dd></dl>
<p>If count is 0, a null string is returned. If count is negative, characters are added in reverse order. <br  />
 e.g. for <code>string str = "example"</code>, <code>str.substr(2,3)</code> will give <code>"amp"</code>, and <code>str.substr(5,-3)</code> will give <code>"pma"</code>. </p>

</div>
</div>
<a id="a3853b1003f645ab83eae642779afa9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3853b1003f645ab83eae642779afa9e2">&#9670;&nbsp;</a></span>toCamel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::toCamel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert all characters in the string to camelcase. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after converting to camelcase. </dd></dl>

</div>
</div>
<a id="ace8b7a630b01a5daaf2e81bd0e97aa26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8b7a630b01a5daaf2e81bd0e97aa26">&#9670;&nbsp;</a></span>toLower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::toLower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert all characters in the string to lowercase. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after converting to lowercase. </dd></dl>

</div>
</div>
<a id="a3f83606d111b9d0ab806a3a948de7c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f83606d111b9d0ab806a3a948de7c50">&#9670;&nbsp;</a></span>toUpper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::toUpper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert all characters in the string to uppercase. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after converting to uppercase. </dd></dl>

</div>
</div>
<a id="a3047a75dfc29b79f0e956e6c1adda93d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3047a75dfc29b79f0e956e6c1adda93d">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::trim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies this string and removes padding from both sides of the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The pad string to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of this string with right-padding removed.</dd></dl>
<p>Removes all occurrences of the given pad string from the left and right sides of this string. </p>

</div>
</div>
<a id="a28ab15bdfd5a290e04e07b2cd34cbc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ab15bdfd5a290e04e07b2cd34cbc05">&#9670;&nbsp;</a></span>trimIn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::trimIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove padding from the both sides of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The pad string to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after removing padding.</dd></dl>
<p>Removes all occurrences of the given pad string from the left and right sides of this string. </p>

</div>
</div>
<a id="a3c1c45a217805b32f69041c5812fcee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1c45a217805b32f69041c5812fcee3">&#9670;&nbsp;</a></span>trimLeft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::trimLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies this string and removes padding from the left side of the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The pad string to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of this string with left-padding removed.</dd></dl>
<p>Removes all occurrences of the given pad string from the left side of this string. </p>

</div>
</div>
<a id="a039bb45cdf70ff3d3334d19e735b42ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039bb45cdf70ff3d3334d19e735b42ac">&#9670;&nbsp;</a></span>trimLeftIn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::trimLeftIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove padding from the left side of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The pad string to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after removing left-padding.</dd></dl>
<p>Removes all occurrences of the given pad string from the left side of this string. </p>

</div>
</div>
<a id="a9f8da0a78e38d9b7abb145721f78ad29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8da0a78e38d9b7abb145721f78ad29">&#9670;&nbsp;</a></span>trimRight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::trimRight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies this string and removes padding from the right side of the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The pad string to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of this string with right-padding removed.</dd></dl>
<p>Removes all occurrences of the given pad string from the right side of this string. </p>

</div>
</div>
<a id="a8afaf63293096ee1d74ebc25bffef82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8afaf63293096ee1d74ebc25bffef82e">&#9670;&nbsp;</a></span>trimRightIn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::trimRightIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove padding from the right side of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The pad string to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after removing right-padding.</dd></dl>
<p>Removes all occurrences of the given pad string from the right side of this string. </p>

</div>
</div>
<a id="a79115a233e715c328a27e051264f9248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79115a233e715c328a27e051264f9248">&#9670;&nbsp;</a></span>truncate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::truncate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all characters from a given index to the end of the string. </p>
<p>This function is faster than <a class="el" href="classz_1_1core_1_1string.html#a4859c295acebf35c40a892af33ef4a65" title="Remove occurrences of the given sub-string.">remove()</a> at truncating string contents, because no actual data copying takes place. The character at the given index is simply set to the null char \0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the first character to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the characters are truncated. </dd></dl>

</div>
</div>
<a id="a8644b4f7292302682dd4aae86a0c2b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8644b4f7292302682dd4aae86a0c2b4d">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>decimal</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the most basic type that this string can cast to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base that numbers are assumed to be in. </td></tr>
    <tr><td class="paramname">decimal</td><td>The character that is used as a decimal separator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the zstr enum representing the type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a010ccdee32ca8973fee25eaeab2e64dc" title="Check if this string can convert to an integer.">isInteger()</a> </dd>
<dd>
<a class="el" href="classz_1_1core_1_1string.html#afe1cd83fd6ca82ac6f2a9e92562804a0" title="Check if this string can convert to a floating-point value.">isFloating()</a> </dd>
<dd>
<a class="el" href="classz_1_1core_1_1string.html#a70f2edc11684860b5741f614d0ddf384" title="Check if this string can convert to a complex value.">isComplex()</a> </dd>
<dd>
isString() </dd></dl>

</div>
</div>
<a id="abe0d76eb1977c8ece5bd35f41faa9178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0d76eb1977c8ece5bd35f41faa9178">&#9670;&nbsp;</a></span>upper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::upper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an uppercase version of this string. </p>
<dl class="section return"><dt>Returns</dt><dd>A duplicate of this string, converted to uppercase. </dd></dl>

</div>
</div>
<a id="a1d51094994baa05a0083222e4d588693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d51094994baa05a0083222e4d588693">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classz_1_1core_1_1outputStream.html">outputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write string data to a stream in that stream's encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf6bcc21f5c030820f9a582d93cee747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6bcc21f5c030820f9a582d93cee747">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classz_1_1core_1_1outputStream.html">outputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="encoding_8hpp.html#abb9b3bdd67c870c617a43438ebb64c17">encoding</a>&#160;</td>
          <td class="paramname"><em>enc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write string data to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to write to. </td></tr>
    <tr><td class="paramname">enc</td><td>The encoding of characters on the stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17986d29aa6a5ca77b6a8c9799ea8f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17986d29aa6a5ca77b6a8c9799ea8f36">&#9670;&nbsp;</a></span>writeln() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::writeln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classz_1_1core_1_1outputStream.html">outputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write string data to a stream in its format, appending a newline. </p>
<p>Actual characters in the newline depends on operating system (usually <code>\n</code>, <code>\r\n</code> on Windows).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabfd03638c0920e1823da50ee80ed1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabfd03638c0920e1823da50ee80ed1f8">&#9670;&nbsp;</a></span>writeln() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::writeln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classz_1_1core_1_1outputStream.html">outputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="encoding_8hpp.html#abb9b3bdd67c870c617a43438ebb64c17">encoding</a>&#160;</td>
          <td class="paramname"><em>enc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write string data to a stream, appending a newline. </p>
<p>Actual characters in the newline depends on operating system (usually <code>\n</code>, <code>\r\n</code> on Windows).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to write to. </td></tr>
    <tr><td class="paramname">enc</td><td>The encoding of characters on the stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ca71321f6cc1fca3825fee6c05a9db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca71321f6cc1fca3825fee6c05a9db7">&#9670;&nbsp;</a></span>wstring()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t* <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::wstring </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the four-byte cstring pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the string data, if this string is in a four-byte format. <code>NULL</code> otherwise. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a1a394438ebafa86857838eeccb1b4718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a394438ebafa86857838eeccb1b4718">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream output operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostr</td><td>The output stream. </td></tr>
    <tr><td class="paramname">str</td><td>The string to write to the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the stream after output. </dd></dl>

</div>
</div>
<a id="a4787e5270acbff46efe5e88f1e63aaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4787e5270acbff46efe5e88f1e63aaa1">&#9670;&nbsp;</a></span>operator&gt;&gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E = utf32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>istr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream input operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istr</td><td>The input stream. </td></tr>
    <tr><td class="paramname">str</td><td>The string to read from the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the stream after input. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>z/core/<a class="el" href="string_8hpp_source.html">string.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>z</b></li><li class="navelem"><a class="el" href="namespacez_1_1core.html">core</a></li><li class="navelem"><a class="el" href="classz_1_1core_1_1string.html">string</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>

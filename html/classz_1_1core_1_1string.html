<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libzed: z::core::string&lt; E &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libzed
   </div>
   <div id="projectbrief">Code libraries for use in other projects</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>z</b></li><li class="navelem"><a class="el" href="namespacez_1_1core.html">core</a></li><li class="navelem"><a class="el" href="classz_1_1core_1_1string.html">string</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classz_1_1core_1_1string-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">z::core::string&lt; E &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A template class for character strings.  
 <a href="classz_1_1core_1_1string.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="string_8h_source.html">string.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for z::core::string&lt; E &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classz_1_1core_1_1string.png" usemap="#z::core::string&lt; E &gt;_map" alt=""/>
  <map id="z::core::string&lt; E &gt;_map" name="z::core::string&lt; E &gt;_map">
<area href="classz_1_1core_1_1serializable.html" title="An interface for reading and writing object binary data to streams. " alt="z::core::serializable" shape="rect" coords="0,0,120,24"/>
<area href="classz_1_1core_1_1sizable.html" title="An interface for getting an object&#39;s size. " alt="z::core::sizable" shape="rect" coords="130,0,250,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac7e51e0e9d38d4e18edfdc8d26138ed1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7e51e0e9d38d4e18edfdc8d26138ed1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ac7e51e0e9d38d4e18edfdc8d26138ed1">string</a> ()</td></tr>
<tr class="memdesc:ac7e51e0e9d38d4e18edfdc8d26138ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default string constructor. <br/></td></tr>
<tr class="separator:ac7e51e0e9d38d4e18edfdc8d26138ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4e304679fb50e54ba6567cac5f8586"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a5b4e304679fb50e54ba6567cac5f8586">string</a> (char chr)</td></tr>
<tr class="memdesc:a5b4e304679fb50e54ba6567cac5f8586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct string from a single-byte character.  <a href="#a5b4e304679fb50e54ba6567cac5f8586">More...</a><br/></td></tr>
<tr class="separator:a5b4e304679fb50e54ba6567cac5f8586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fbb9ffdb08666f1fcfccb662f49a06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a71fbb9ffdb08666f1fcfccb662f49a06">string</a> (wchar_t chr)</td></tr>
<tr class="memdesc:a71fbb9ffdb08666f1fcfccb662f49a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct string from a wide character.  <a href="#a71fbb9ffdb08666f1fcfccb662f49a06">More...</a><br/></td></tr>
<tr class="separator:a71fbb9ffdb08666f1fcfccb662f49a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0439d1cfb4081a5c8ab1ccd24ed566f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aa0439d1cfb4081a5c8ab1ccd24ed566f">string</a> (const uint32_t &amp;chr)</td></tr>
<tr class="memdesc:aa0439d1cfb4081a5c8ab1ccd24ed566f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct string from uint32_t.  <a href="#aa0439d1cfb4081a5c8ab1ccd24ed566f">More...</a><br/></td></tr>
<tr class="separator:aa0439d1cfb4081a5c8ab1ccd24ed566f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9c955b880c2b48c463ddd29d221477"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a4f9c955b880c2b48c463ddd29d221477">string</a> (const char *str)</td></tr>
<tr class="memdesc:a4f9c955b880c2b48c463ddd29d221477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a cstring of single-byte characters.  <a href="#a4f9c955b880c2b48c463ddd29d221477">More...</a><br/></td></tr>
<tr class="separator:a4f9c955b880c2b48c463ddd29d221477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeee49af0a680fc5921c6474861e10cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#adeee49af0a680fc5921c6474861e10cd">string</a> (const wchar_t *str)</td></tr>
<tr class="memdesc:adeee49af0a680fc5921c6474861e10cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a cstring of wide characters.  <a href="#adeee49af0a680fc5921c6474861e10cd">More...</a><br/></td></tr>
<tr class="separator:adeee49af0a680fc5921c6474861e10cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0668671800b1a23d2c779b36eee78e5"><td class="memTemplParams" colspan="2">template&lt;typename INT , typename  = typename std::enable_if&lt;std::is_integral&lt;INT&gt;::value,INT&gt;::type&gt; </td></tr>
<tr class="memitem:ab0668671800b1a23d2c779b36eee78e5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ab0668671800b1a23d2c779b36eee78e5">string</a> (INT value, unsigned int base=10, unsigned int padSize=0)</td></tr>
<tr class="memdesc:ab0668671800b1a23d2c779b36eee78e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from an integer.  <a href="#ab0668671800b1a23d2c779b36eee78e5">More...</a><br/></td></tr>
<tr class="separator:ab0668671800b1a23d2c779b36eee78e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d462e29dc6627b94752c1fb420c84d"><td class="memTemplParams" colspan="2">template&lt;typename PTR , typename  = typename std::enable_if&lt;std::is_pointer&lt;PTR&gt;::value,PTR&gt;::type&gt; </td></tr>
<tr class="memitem:a89d462e29dc6627b94752c1fb420c84d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a89d462e29dc6627b94752c1fb420c84d">string</a> (PTR pointer)</td></tr>
<tr class="memdesc:a89d462e29dc6627b94752c1fb420c84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a pointer.  <a href="#a89d462e29dc6627b94752c1fb420c84d">More...</a><br/></td></tr>
<tr class="separator:a89d462e29dc6627b94752c1fb420c84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd250e94254ed8fefe0347384f5b76d"><td class="memTemplParams" colspan="2">template&lt;typename FLT , typename  = typename std::enable_if&lt;std::is_floating_point&lt;FLT&gt;::value,FLT&gt;::type&gt; </td></tr>
<tr class="memitem:a7dd250e94254ed8fefe0347384f5b76d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a7dd250e94254ed8fefe0347384f5b76d">string</a> (FLT value, unsigned int base=10, unsigned int precision=0, unsigned int padSize=0)</td></tr>
<tr class="memdesc:a7dd250e94254ed8fefe0347384f5b76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from floating-point.  <a href="#a7dd250e94254ed8fefe0347384f5b76d">More...</a><br/></td></tr>
<tr class="separator:a7dd250e94254ed8fefe0347384f5b76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe34b7ec7bab5a158427cfff00da36c6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value,T&gt;::type&gt; </td></tr>
<tr class="memitem:abe34b7ec7bab5a158427cfff00da36c6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#abe34b7ec7bab5a158427cfff00da36c6">string</a> (const std::complex&lt; T &gt; &amp;value, unsigned int base=10, unsigned int precision=0)</td></tr>
<tr class="memdesc:abe34b7ec7bab5a158427cfff00da36c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from complex number.  <a href="#abe34b7ec7bab5a158427cfff00da36c6">More...</a><br/></td></tr>
<tr class="separator:abe34b7ec7bab5a158427cfff00da36c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535efedc62c854b849c57c167305b13f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a535efedc62c854b849c57c167305b13f">string</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; ascii &gt; &amp;other)</td></tr>
<tr class="memdesc:a535efedc62c854b849c57c167305b13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from an ASCII string.  <a href="#a535efedc62c854b849c57c167305b13f">More...</a><br/></td></tr>
<tr class="separator:a535efedc62c854b849c57c167305b13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6e7832d611f98ac8fa7eb5cb581347"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a2e6e7832d611f98ac8fa7eb5cb581347">string</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; utf8 &gt; &amp;other)</td></tr>
<tr class="memdesc:a2e6e7832d611f98ac8fa7eb5cb581347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a UTF-8 string.  <a href="#a2e6e7832d611f98ac8fa7eb5cb581347">More...</a><br/></td></tr>
<tr class="separator:a2e6e7832d611f98ac8fa7eb5cb581347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e33334d160bab82c66b804ada479cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a36e33334d160bab82c66b804ada479cb">string</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; utf16 &gt; &amp;other)</td></tr>
<tr class="memdesc:a36e33334d160bab82c66b804ada479cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a UTF16 string.  <a href="#a36e33334d160bab82c66b804ada479cb">More...</a><br/></td></tr>
<tr class="separator:a36e33334d160bab82c66b804ada479cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7edd60be02b0a5174af2abe27cabc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a2a7edd60be02b0a5174af2abe27cabc7">string</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; utf32 &gt; &amp;other)</td></tr>
<tr class="memdesc:a2a7edd60be02b0a5174af2abe27cabc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a UTF32 string.  <a href="#a2a7edd60be02b0a5174af2abe27cabc7">More...</a><br/></td></tr>
<tr class="separator:a2a7edd60be02b0a5174af2abe27cabc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc074690cfd42fd243b6718fccc86fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#abdc074690cfd42fd243b6718fccc86fe">~string</a> ()</td></tr>
<tr class="memdesc:abdc074690cfd42fd243b6718fccc86fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lvalue copy-constructor.  <a href="#abdc074690cfd42fd243b6718fccc86fe">More...</a><br/></td></tr>
<tr class="separator:abdc074690cfd42fd243b6718fccc86fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab808c847f34b92d16ce7b5d03feb77f5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ab808c847f34b92d16ce7b5d03feb77f5">at</a> (size_t index) const </td></tr>
<tr class="memdesc:ab808c847f34b92d16ce7b5d03feb77f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the character at the given index.  <a href="#ab808c847f34b92d16ce7b5d03feb77f5">More...</a><br/></td></tr>
<tr class="separator:ab808c847f34b92d16ce7b5d03feb77f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fef7b87b351d545968a364ee5f22a9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aa7fef7b87b351d545968a364ee5f22a9">operator[]</a> (size_t index) const </td></tr>
<tr class="memdesc:aa7fef7b87b351d545968a364ee5f22a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the character at the given index.  <a href="#aa7fef7b87b351d545968a364ee5f22a9">More...</a><br/></td></tr>
<tr class="separator:aa7fef7b87b351d545968a364ee5f22a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53eeb89cc5d269014a945968597e38c4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a53eeb89cc5d269014a945968597e38c4">size</a> () const </td></tr>
<tr class="memdesc:a53eeb89cc5d269014a945968597e38c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the string in memory.  <a href="#a53eeb89cc5d269014a945968597e38c4">More...</a><br/></td></tr>
<tr class="separator:a53eeb89cc5d269014a945968597e38c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ece138e99ff49a4bd56382bed816aeb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a8ece138e99ff49a4bd56382bed816aeb">length</a> () const </td></tr>
<tr class="memdesc:a8ece138e99ff49a4bd56382bed816aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the character count of the string.  <a href="#a8ece138e99ff49a4bd56382bed816aeb">More...</a><br/></td></tr>
<tr class="separator:a8ece138e99ff49a4bd56382bed816aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d4052c0c352352e49e020ded382eb5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a34d4052c0c352352e49e020ded382eb5">chars</a> () const </td></tr>
<tr class="memdesc:a34d4052c0c352352e49e020ded382eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the individual character count of the string.  <a href="#a34d4052c0c352352e49e020ded382eb5">More...</a><br/></td></tr>
<tr class="separator:a34d4052c0c352352e49e020ded382eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a11acc341f669f44df588a126c8a03"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ab1a11acc341f669f44df588a126c8a03">cstring</a> () const </td></tr>
<tr class="memdesc:ab1a11acc341f669f44df588a126c8a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the single-byte cstring pointer.  <a href="#ab1a11acc341f669f44df588a126c8a03">More...</a><br/></td></tr>
<tr class="separator:ab1a11acc341f669f44df588a126c8a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac597cf4800109be5d57875e918498570"><td class="memItemLeft" align="right" valign="top">const uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ac597cf4800109be5d57875e918498570">nstring</a> () const </td></tr>
<tr class="memdesc:ac597cf4800109be5d57875e918498570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the two-byte cstring pointer.  <a href="#ac597cf4800109be5d57875e918498570">More...</a><br/></td></tr>
<tr class="separator:ac597cf4800109be5d57875e918498570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e684f962c14ef88c1fe5bde851091e6"><td class="memItemLeft" align="right" valign="top">const uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a6e684f962c14ef88c1fe5bde851091e6">wstring</a> () const </td></tr>
<tr class="memdesc:a6e684f962c14ef88c1fe5bde851091e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the four-byte cstring pointer.  <a href="#a6e684f962c14ef88c1fe5bde851091e6">More...</a><br/></td></tr>
<tr class="separator:a6e684f962c14ef88c1fe5bde851091e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac160a02dcc5ca76456bfcbf4638c28d7"><td class="memItemLeft" align="right" valign="top">constexpr encoding&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ac160a02dcc5ca76456bfcbf4638c28d7">format</a> () const </td></tr>
<tr class="memdesc:ac160a02dcc5ca76456bfcbf4638c28d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the encoding of this string.  <a href="#ac160a02dcc5ca76456bfcbf4638c28d7">More...</a><br/></td></tr>
<tr class="separator:ac160a02dcc5ca76456bfcbf4638c28d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b2c3667a94126667653e8266b6577e"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a14b2c3667a94126667653e8266b6577e">integer</a> (int base=10) const </td></tr>
<tr class="memdesc:a14b2c3667a94126667653e8266b6577e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this string to an integer.  <a href="#a14b2c3667a94126667653e8266b6577e">More...</a><br/></td></tr>
<tr class="separator:a14b2c3667a94126667653e8266b6577e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8d5137e0941a24b1e523f456c260ec"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aeb8d5137e0941a24b1e523f456c260ec">floating</a> (int base=10) const </td></tr>
<tr class="memdesc:aeb8d5137e0941a24b1e523f456c260ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this string to a floating-point value.  <a href="#aeb8d5137e0941a24b1e523f456c260ec">More...</a><br/></td></tr>
<tr class="separator:aeb8d5137e0941a24b1e523f456c260ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8669c07cf59dc85ebbd27c3a21771a8"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#af8669c07cf59dc85ebbd27c3a21771a8">complex</a> (int base=10) const </td></tr>
<tr class="memdesc:af8669c07cf59dc85ebbd27c3a21771a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this string to a complex value.  <a href="#af8669c07cf59dc85ebbd27c3a21771a8">More...</a><br/></td></tr>
<tr class="separator:af8669c07cf59dc85ebbd27c3a21771a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e4d260010465ba4c9b6042d1b04e96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a64e4d260010465ba4c9b6042d1b04e96">count</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const </td></tr>
<tr class="memdesc:a64e4d260010465ba4c9b6042d1b04e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the occurrences of a sub-string.  <a href="#a64e4d260010465ba4c9b6042d1b04e96">More...</a><br/></td></tr>
<tr class="separator:a64e4d260010465ba4c9b6042d1b04e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d92098b1dbb6d49eadf7a0df9dc8479"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a5d92098b1dbb6d49eadf7a0df9dc8479">find</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, int occurrence=1) const </td></tr>
<tr class="memdesc:a5d92098b1dbb6d49eadf7a0df9dc8479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a specific occurrence of a sub-string.  <a href="#a5d92098b1dbb6d49eadf7a0df9dc8479">More...</a><br/></td></tr>
<tr class="separator:a5d92098b1dbb6d49eadf7a0df9dc8479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29dccb5c3e1f52db8c21e0d9262dc56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aa29dccb5c3e1f52db8c21e0d9262dc56">findLast</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, int occurrence=1) const </td></tr>
<tr class="memdesc:aa29dccb5c3e1f52db8c21e0d9262dc56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse-find a specific occurrence of a sub-string.  <a href="#aa29dccb5c3e1f52db8c21e0d9262dc56">More...</a><br/></td></tr>
<tr class="separator:aa29dccb5c3e1f52db8c21e0d9262dc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9324dc9c2b66f15f260a3dfd569db3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a3e9324dc9c2b66f15f260a3dfd569db3">findAfter</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, size_t index, int occurrence=1) const </td></tr>
<tr class="memdesc:a3e9324dc9c2b66f15f260a3dfd569db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a specific occurrence of a sub-string.  <a href="#a3e9324dc9c2b66f15f260a3dfd569db3">More...</a><br/></td></tr>
<tr class="separator:a3e9324dc9c2b66f15f260a3dfd569db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c119f72cb30db17bedcd6bd47866fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aa3c119f72cb30db17bedcd6bd47866fe">findBefore</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, size_t index, int occurrence=1) const </td></tr>
<tr class="memdesc:aa3c119f72cb30db17bedcd6bd47866fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse-find a specific occurrence of a sub-string.  <a href="#aa3c119f72cb30db17bedcd6bd47866fe">More...</a><br/></td></tr>
<tr class="separator:aa3c119f72cb30db17bedcd6bd47866fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9556b726933f79af8bdf4a5794768f66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a9556b726933f79af8bdf4a5794768f66">foundAt</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, size_t index) const </td></tr>
<tr class="memdesc:a9556b726933f79af8bdf4a5794768f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a sub-string is found at the given index.  <a href="#a9556b726933f79af8bdf4a5794768f66">More...</a><br/></td></tr>
<tr class="separator:a9556b726933f79af8bdf4a5794768f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc3f1f53816a5309fddc8f370862def"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aadc3f1f53816a5309fddc8f370862def">foundEndAt</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, size_t index) const </td></tr>
<tr class="memdesc:aadc3f1f53816a5309fddc8f370862def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a sub-string ends at the given index.  <a href="#aadc3f1f53816a5309fddc8f370862def">More...</a><br/></td></tr>
<tr class="separator:aadc3f1f53816a5309fddc8f370862def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a9d20e265f36525db8922c9b57fa5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aa5a9d20e265f36525db8922c9b57fa5f">beginsWith</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const </td></tr>
<tr class="memdesc:aa5a9d20e265f36525db8922c9b57fa5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the string begins with a given sub-string.  <a href="#aa5a9d20e265f36525db8922c9b57fa5f">More...</a><br/></td></tr>
<tr class="separator:aa5a9d20e265f36525db8922c9b57fa5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9683b4fd5015aa3f9b73489cb4fa0a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ab9683b4fd5015aa3f9b73489cb4fa0a5">endsWith</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const </td></tr>
<tr class="memdesc:ab9683b4fd5015aa3f9b73489cb4fa0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the string ends with a given sub-string.  <a href="#ab9683b4fd5015aa3f9b73489cb4fa0a5">More...</a><br/></td></tr>
<tr class="separator:ab9683b4fd5015aa3f9b73489cb4fa0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dde7e9fb2c7006fc653e173c64fb7fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a6dde7e9fb2c7006fc653e173c64fb7fe">isInteger</a> (int base=10) const </td></tr>
<tr class="memdesc:a6dde7e9fb2c7006fc653e173c64fb7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string can convert to an integer.  <a href="#a6dde7e9fb2c7006fc653e173c64fb7fe">More...</a><br/></td></tr>
<tr class="separator:a6dde7e9fb2c7006fc653e173c64fb7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c25c7b1c7b83f89f27b817067435918"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a3c25c7b1c7b83f89f27b817067435918">isFloating</a> (int base=10) const </td></tr>
<tr class="memdesc:a3c25c7b1c7b83f89f27b817067435918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string can convert to a floating-point value.  <a href="#a3c25c7b1c7b83f89f27b817067435918">More...</a><br/></td></tr>
<tr class="separator:a3c25c7b1c7b83f89f27b817067435918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacd7da8f29459c70c0049ccb1ab42bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#acacd7da8f29459c70c0049ccb1ab42bb">isComplex</a> (int base=10) const </td></tr>
<tr class="memdesc:acacd7da8f29459c70c0049ccb1ab42bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string can convert to a complex value.  <a href="#acacd7da8f29459c70c0049ccb1ab42bb">More...</a><br/></td></tr>
<tr class="separator:acacd7da8f29459c70c0049ccb1ab42bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85444b48a6d7fc97801080db8679e0ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a85444b48a6d7fc97801080db8679e0ac">substr</a> (size_t index, int <a class="el" href="classz_1_1core_1_1string.html#a64e4d260010465ba4c9b6042d1b04e96">count</a>) const </td></tr>
<tr class="memdesc:a85444b48a6d7fc97801080db8679e0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a sub-string from this string.  <a href="#a85444b48a6d7fc97801080db8679e0ac">More...</a><br/></td></tr>
<tr class="separator:a85444b48a6d7fc97801080db8679e0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebc6a5b873a2d834dbd604548256a38"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a7ebc6a5b873a2d834dbd604548256a38">append</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other)</td></tr>
<tr class="memdesc:a7ebc6a5b873a2d834dbd604548256a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append another string to the end of this one.  <a href="#a7ebc6a5b873a2d834dbd604548256a38">More...</a><br/></td></tr>
<tr class="separator:a7ebc6a5b873a2d834dbd604548256a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca681e97ec1f2142c36bc15a2d6deba4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aca681e97ec1f2142c36bc15a2d6deba4">insert</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, size_t index)</td></tr>
<tr class="memdesc:aca681e97ec1f2142c36bc15a2d6deba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert another string into this one.  <a href="#aca681e97ec1f2142c36bc15a2d6deba4">More...</a><br/></td></tr>
<tr class="separator:aca681e97ec1f2142c36bc15a2d6deba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ceba196566b8c42e61e860411f6a6c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aa1ceba196566b8c42e61e860411f6a6c">remove</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, int occurrence=0)</td></tr>
<tr class="memdesc:aa1ceba196566b8c42e61e860411f6a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove occurrences of the given sub-string.  <a href="#aa1ceba196566b8c42e61e860411f6a6c">More...</a><br/></td></tr>
<tr class="separator:aa1ceba196566b8c42e61e860411f6a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef27468b8aa1926f0d771e05f06562f3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aef27468b8aa1926f0d771e05f06562f3">remove</a> (size_t index, int <a class="el" href="classz_1_1core_1_1string.html#a64e4d260010465ba4c9b6042d1b04e96">count</a>)</td></tr>
<tr class="memdesc:aef27468b8aa1926f0d771e05f06562f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a subset of the string.  <a href="#aef27468b8aa1926f0d771e05f06562f3">More...</a><br/></td></tr>
<tr class="separator:aef27468b8aa1926f0d771e05f06562f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a352e8676093675d0fb029bc8d9c19"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#ae3a352e8676093675d0fb029bc8d9c19">replace</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;findStr, const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;replStr, int occurrence=0)</td></tr>
<tr class="memdesc:ae3a352e8676093675d0fb029bc8d9c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace occurrences of the given sub-string.  <a href="#ae3a352e8676093675d0fb029bc8d9c19">More...</a><br/></td></tr>
<tr class="separator:ae3a352e8676093675d0fb029bc8d9c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d012318f44f3e5e3e2e1bd971341f2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a48d012318f44f3e5e3e2e1bd971341f2">replace</a> (size_t index, int <a class="el" href="classz_1_1core_1_1string.html#a64e4d260010465ba4c9b6042d1b04e96">count</a>, const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other)</td></tr>
<tr class="memdesc:a48d012318f44f3e5e3e2e1bd971341f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a subset of the string.  <a href="#a48d012318f44f3e5e3e2e1bd971341f2">More...</a><br/></td></tr>
<tr class="separator:a48d012318f44f3e5e3e2e1bd971341f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c751f00887e9aec65ca0fecdf2888ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a5c751f00887e9aec65ca0fecdf2888ea">padLeft</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, size_t padSize)</td></tr>
<tr class="memdesc:a5c751f00887e9aec65ca0fecdf2888ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-pad this string up to a given chracter count.  <a href="#a5c751f00887e9aec65ca0fecdf2888ea">More...</a><br/></td></tr>
<tr class="separator:a5c751f00887e9aec65ca0fecdf2888ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99afadac69e5c4b1ea90e0c80d73092e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a99afadac69e5c4b1ea90e0c80d73092e">padRight</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other, size_t padSize)</td></tr>
<tr class="memdesc:a99afadac69e5c4b1ea90e0c80d73092e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-pad this string up to a given chracter count.  <a href="#a99afadac69e5c4b1ea90e0c80d73092e">More...</a><br/></td></tr>
<tr class="separator:a99afadac69e5c4b1ea90e0c80d73092e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831d59c0272e84650709aafedde14419"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a831d59c0272e84650709aafedde14419">trimLeft</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other)</td></tr>
<tr class="memdesc:a831d59c0272e84650709aafedde14419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove padding from the left side of this string.  <a href="#a831d59c0272e84650709aafedde14419">More...</a><br/></td></tr>
<tr class="separator:a831d59c0272e84650709aafedde14419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2746636a6364150dd3173e20b6e255e4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a2746636a6364150dd3173e20b6e255e4">trimRight</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other)</td></tr>
<tr class="memdesc:a2746636a6364150dd3173e20b6e255e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove padding from the right side of this string.  <a href="#a2746636a6364150dd3173e20b6e255e4">More...</a><br/></td></tr>
<tr class="separator:a2746636a6364150dd3173e20b6e255e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4692a7a8aceb41ba7f5281183d642afc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a4692a7a8aceb41ba7f5281183d642afc">trim</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other)</td></tr>
<tr class="memdesc:a4692a7a8aceb41ba7f5281183d642afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove padding from the both sides of this string.  <a href="#a4692a7a8aceb41ba7f5281183d642afc">More...</a><br/></td></tr>
<tr class="separator:a4692a7a8aceb41ba7f5281183d642afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a5b51d54ba1a67e232ce459c76e178"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a11a5b51d54ba1a67e232ce459c76e178">cutDuplicates</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other)</td></tr>
<tr class="memdesc:a11a5b51d54ba1a67e232ce459c76e178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all sequential duplicates from this string.  <a href="#a11a5b51d54ba1a67e232ce459c76e178">More...</a><br/></td></tr>
<tr class="separator:a11a5b51d54ba1a67e232ce459c76e178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb9e82aa54fb7bb1fc08a1930d2f2ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a2fb9e82aa54fb7bb1fc08a1930d2f2ca">upper</a> () const </td></tr>
<tr class="memdesc:a2fb9e82aa54fb7bb1fc08a1930d2f2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all characters in the string to uppercase.  <a href="#a2fb9e82aa54fb7bb1fc08a1930d2f2ca">More...</a><br/></td></tr>
<tr class="separator:a2fb9e82aa54fb7bb1fc08a1930d2f2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4c1fb525e6d99631fa34594ce37856"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aab4c1fb525e6d99631fa34594ce37856">lower</a> () const </td></tr>
<tr class="memdesc:aab4c1fb525e6d99631fa34594ce37856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all characters in the string to lowercase.  <a href="#aab4c1fb525e6d99631fa34594ce37856">More...</a><br/></td></tr>
<tr class="separator:aab4c1fb525e6d99631fa34594ce37856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a130e7f8527bac3208ac8dbe8b57c19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a6a130e7f8527bac3208ac8dbe8b57c19">camel</a> () const </td></tr>
<tr class="memdesc:a6a130e7f8527bac3208ac8dbe8b57c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all characters in the string to camelcase.  <a href="#a6a130e7f8527bac3208ac8dbe8b57c19">More...</a><br/></td></tr>
<tr class="separator:a6a130e7f8527bac3208ac8dbe8b57c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47ffefe13f1ee573e4f0a020cd3afe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classz_1_1core_1_1string.html">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aa47ffefe13f1ee573e4f0a020cd3afe7">operator+</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const </td></tr>
<tr class="memdesc:aa47ffefe13f1ee573e4f0a020cd3afe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two strings.  <a href="#aa47ffefe13f1ee573e4f0a020cd3afe7">More...</a><br/></td></tr>
<tr class="separator:aa47ffefe13f1ee573e4f0a020cd3afe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e91ace781f0f0d0b30011ab6d3922a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a74e91ace781f0f0d0b30011ab6d3922a">operator+=</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other)</td></tr>
<tr class="memdesc:a74e91ace781f0f0d0b30011ab6d3922a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append another string to the end of this one.  <a href="#a74e91ace781f0f0d0b30011ab6d3922a">More...</a><br/></td></tr>
<tr class="separator:a74e91ace781f0f0d0b30011ab6d3922a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92467431a93dafbc4349e266c6083b4b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a92467431a93dafbc4349e266c6083b4b">operator=</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other)</td></tr>
<tr class="memdesc:a92467431a93dafbc4349e266c6083b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the contents of this string.  <a href="#a92467431a93dafbc4349e266c6083b4b">More...</a><br/></td></tr>
<tr class="separator:a92467431a93dafbc4349e266c6083b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb3470ad2b461dfab6ca4fddc210b6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#adfb3470ad2b461dfab6ca4fddc210b6a">operator==</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const </td></tr>
<tr class="memdesc:adfb3470ad2b461dfab6ca4fddc210b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison.  <a href="#adfb3470ad2b461dfab6ca4fddc210b6a">More...</a><br/></td></tr>
<tr class="separator:adfb3470ad2b461dfab6ca4fddc210b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d92960f8b55d2726607ae72d9d3e50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a83d92960f8b55d2726607ae72d9d3e50">operator!=</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const </td></tr>
<tr class="memdesc:a83d92960f8b55d2726607ae72d9d3e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison.  <a href="#a83d92960f8b55d2726607ae72d9d3e50">More...</a><br/></td></tr>
<tr class="separator:a83d92960f8b55d2726607ae72d9d3e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3188d5c2d80de7ca4d9f6a0ff2caa2d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a3188d5c2d80de7ca4d9f6a0ff2caa2d7">operator&gt;</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const </td></tr>
<tr class="memdesc:a3188d5c2d80de7ca4d9f6a0ff2caa2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison.  <a href="#a3188d5c2d80de7ca4d9f6a0ff2caa2d7">More...</a><br/></td></tr>
<tr class="separator:a3188d5c2d80de7ca4d9f6a0ff2caa2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e196397c884a26b9b54d8a52641ea5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a74e196397c884a26b9b54d8a52641ea5">operator&gt;=</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const </td></tr>
<tr class="memdesc:a74e196397c884a26b9b54d8a52641ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than or equal comparison.  <a href="#a74e196397c884a26b9b54d8a52641ea5">More...</a><br/></td></tr>
<tr class="separator:a74e196397c884a26b9b54d8a52641ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cc49d709ebcb37b40c1352e53f8f3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a92cc49d709ebcb37b40c1352e53f8f3d">operator&lt;</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const </td></tr>
<tr class="memdesc:a92cc49d709ebcb37b40c1352e53f8f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison.  <a href="#a92cc49d709ebcb37b40c1352e53f8f3d">More...</a><br/></td></tr>
<tr class="separator:a92cc49d709ebcb37b40c1352e53f8f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6ed070a6d32f0b1af05ba1f10cb5a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a8b6ed070a6d32f0b1af05ba1f10cb5a9">operator&lt;=</a> (const <a class="el" href="classz_1_1core_1_1string.html">string</a> &amp;other) const </td></tr>
<tr class="memdesc:a8b6ed070a6d32f0b1af05ba1f10cb5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than or equal comparison.  <a href="#a8b6ed070a6d32f0b1af05ba1f10cb5a9">More...</a><br/></td></tr>
<tr class="separator:a8b6ed070a6d32f0b1af05ba1f10cb5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0515d4ce68ea76fd5d480c4e9ab9a252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a0515d4ce68ea76fd5d480c4e9ab9a252">serialIn</a> (<a class="el" href="classz_1_1core_1_1inputStream.html">inputStream</a> &amp;)</td></tr>
<tr class="memdesc:a0515d4ce68ea76fd5d480c4e9ab9a252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the object's binary data from a stream.  <a href="#a0515d4ce68ea76fd5d480c4e9ab9a252">More...</a><br/></td></tr>
<tr class="separator:a0515d4ce68ea76fd5d480c4e9ab9a252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb5e002571fe8fa3c7c7c360702227e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#aedb5e002571fe8fa3c7c7c360702227e">serialOut</a> (<a class="el" href="classz_1_1core_1_1outputStream.html">outputStream</a> &amp;) const </td></tr>
<tr class="memdesc:aedb5e002571fe8fa3c7c7c360702227e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the object's binary data to a stream.  <a href="#aedb5e002571fe8fa3c7c7c360702227e">More...</a><br/></td></tr>
<tr class="separator:aedb5e002571fe8fa3c7c7c360702227e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047e728df74bc7ea0ab801716640fbc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a047e728df74bc7ea0ab801716640fbc8">read</a> (<a class="el" href="classz_1_1core_1_1inputStream.html">inputStream</a> &amp;<a class="el" href="classz_1_1core_1_1stream.html">stream</a>, uint32_t delim=0)</td></tr>
<tr class="memdesc:a047e728df74bc7ea0ab801716640fbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read string data from a stream until the given delimiter is encountered.  <a href="#a047e728df74bc7ea0ab801716640fbc8">More...</a><br/></td></tr>
<tr class="separator:a047e728df74bc7ea0ab801716640fbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9e2cfd0c1f533783214e36b7943879"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#afa9e2cfd0c1f533783214e36b7943879">readln</a> (<a class="el" href="classz_1_1core_1_1inputStream.html">inputStream</a> &amp;<a class="el" href="classz_1_1core_1_1stream.html">stream</a>)</td></tr>
<tr class="memdesc:afa9e2cfd0c1f533783214e36b7943879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read string data from a stream until a newline is encountered.  <a href="#afa9e2cfd0c1f533783214e36b7943879">More...</a><br/></td></tr>
<tr class="separator:afa9e2cfd0c1f533783214e36b7943879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f90a793a0a4003329ddeb7a15a2f537"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a8f90a793a0a4003329ddeb7a15a2f537">write</a> (<a class="el" href="classz_1_1core_1_1outputStream.html">outputStream</a> &amp;<a class="el" href="classz_1_1core_1_1stream.html">stream</a>) const </td></tr>
<tr class="memdesc:a8f90a793a0a4003329ddeb7a15a2f537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write string data to a stream.  <a href="#a8f90a793a0a4003329ddeb7a15a2f537">More...</a><br/></td></tr>
<tr class="separator:a8f90a793a0a4003329ddeb7a15a2f537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860593a1714db9eee57b898072370d92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1string.html#a860593a1714db9eee57b898072370d92">writeln</a> (<a class="el" href="classz_1_1core_1_1outputStream.html">outputStream</a> &amp;<a class="el" href="classz_1_1core_1_1stream.html">stream</a>) const </td></tr>
<tr class="memdesc:a860593a1714db9eee57b898072370d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write string data to a stream, appending a newline.  <a href="#a860593a1714db9eee57b898072370d92">More...</a><br/></td></tr>
<tr class="separator:a860593a1714db9eee57b898072370d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classz_1_1core_1_1serializable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classz_1_1core_1_1serializable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classz_1_1core_1_1serializable.html">z::core::serializable</a></td></tr>
<tr class="memitem:a531923d38bc223a5255223efd22ede98 inherit pub_methods_classz_1_1core_1_1serializable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a531923d38bc223a5255223efd22ede98"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1serializable.html#a531923d38bc223a5255223efd22ede98">~serializable</a> ()</td></tr>
<tr class="memdesc:a531923d38bc223a5255223efd22ede98 inherit pub_methods_classz_1_1core_1_1serializable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br/></td></tr>
<tr class="separator:a531923d38bc223a5255223efd22ede98 inherit pub_methods_classz_1_1core_1_1serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classz_1_1core_1_1sizable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classz_1_1core_1_1sizable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classz_1_1core_1_1sizable.html">z::core::sizable</a></td></tr>
<tr class="memitem:a531d70e7355f2694ad3176c57312cd86 inherit pub_methods_classz_1_1core_1_1sizable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a531d70e7355f2694ad3176c57312cd86"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classz_1_1core_1_1sizable.html#a531d70e7355f2694ad3176c57312cd86">~sizable</a> ()</td></tr>
<tr class="memdesc:a531d70e7355f2694ad3176c57312cd86 inherit pub_methods_classz_1_1core_1_1sizable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br/></td></tr>
<tr class="separator:a531d70e7355f2694ad3176c57312cd86 inherit pub_methods_classz_1_1core_1_1sizable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;encoding E&gt;<br/>
class z::core::string&lt; E &gt;</h3>

<p>A template class for character strings. </p>
<p>This class focuses on how characters are encoded rather than character size. Possible encoding schemes are ASCII, UTF-8, UTF16, and UTF32. When characters are input or output, they are converted to or from their encoding scheme to a single UTF32 character. Thus, the "default" character type is <code>uint32_t</code>. <br/>
<br/>
 Allocated memory is increased as needed with approximate 1.5x growth, and is not decreased on subsequent data changes, except in the case where data is copied over to a different string. <br/>
<br/>
 <b>RE-ENTRANCE:</b><br/>
 Simultaneous accesses to the same object can cause data races. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5b4e304679fb50e54ba6567cac5f8586"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>chr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct string from a single-byte character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chr</td><td>Initializing character.</td></tr>
  </table>
  </dd>
</dl>
<p>Character is assumed to be compatible with this string's encoding. </p>

</div>
</div>
<a class="anchor" id="a71fbb9ffdb08666f1fcfccb662f49a06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">wchar_t&#160;</td>
          <td class="paramname"><em>chr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct string from a wide character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chr</td><td>Initializing character.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts the given character to the appropriate encoding for this string. </p>

</div>
</div>
<a class="anchor" id="aa0439d1cfb4081a5c8ab1ccd24ed566f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>chr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct string from uint32_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chr</td><td>Initializing character.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor exists to allow a "default" string character to again be constructed into a string. Converts the given character to the appropriate encoding for this string.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#ab808c847f34b92d16ce7b5d03feb77f5" title="Get the character at the given index. ">at()</a> </dd>
<dd>
<a class="el" href="classz_1_1core_1_1string.html#aa7fef7b87b351d545968a364ee5f22a9" title="Get the character at the given index. ">operator[]()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4f9c955b880c2b48c463ddd29d221477"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from a cstring of single-byte characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Null-terminated cstring.</td></tr>
  </table>
  </dd>
</dl>
<p>All characters are assumed to be compatible with this string's encoding. </p>

</div>
</div>
<a class="anchor" id="adeee49af0a680fc5921c6474861e10cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from a cstring of wide characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Null-terminated cstring.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts the characters in the given cstring to the appropriate encoding for this string. </p>

</div>
</div>
<a class="anchor" id="ab0668671800b1a23d2c779b36eee78e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
<div class="memtemplate">
template&lt;typename INT , typename  = typename std::enable_if&lt;std::is_integral&lt;INT&gt;::value,INT&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>padSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from an integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An integer. </td></tr>
    <tr><td class="paramname">base</td><td>The number's base. </td></tr>
    <tr><td class="paramname">padSize</td><td>Number of characters to pad up to.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts an integer to a string in the given base. If the character count is less than the pad size, zeroes are added to the left side until the character count equals the pad size. Valid base sizes are from 2 to 36, and anything else is assumed to be base 10. If the pad size is less than 1, no character padding is applied. </p>

</div>
</div>
<a class="anchor" id="a89d462e29dc6627b94752c1fb420c84d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
<div class="memtemplate">
template&lt;typename PTR , typename  = typename std::enable_if&lt;std::is_pointer&lt;PTR&gt;::value,PTR&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">PTR&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>A pointer.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates a string representation from a pointer, of the form <code>0xFFFFFFFF</code>. If <code>Z_STR_POINTER_FORCE</code> is defined as <code>true</code>, then the hex part of the string is padded up to <code>Z_STR_POINTER_CHARS</code> characters (default is 8). </p>

</div>
</div>
<a class="anchor" id="a7dd250e94254ed8fefe0347384f5b76d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
<div class="memtemplate">
template&lt;typename FLT , typename  = typename std::enable_if&lt;std::is_floating_point&lt;FLT&gt;::value,FLT&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">FLT&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>padSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from floating-point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A floating-point number. </td></tr>
    <tr><td class="paramname">base</td><td>The number's base. </td></tr>
    <tr><td class="paramname">precision</td><td>The number of characters after the decimal point. </td></tr>
    <tr><td class="paramname">padSize</td><td>Number of characters to pad up to.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts a floating-point number to a string in the given base. If the character count is less than the pad size, zeroes are added to the left side until the character count equals the pad size. Valid base sizes are from 2 to 36, and anything else is assumed to be base 10. If the pad size is less than 1, no character padding is applied. If the precision is 1 or greater, then exactly that many digits will show after the decimal point, otherwise up to <code>Z_STR_FLOAT_PRECISION</code> digits will show (default is 6). </p>

</div>
</div>
<a class="anchor" id="abe34b7ec7bab5a158427cfff00da36c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value,T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A floating-point complex number. </td></tr>
    <tr><td class="paramname">base</td><td>The number's base. </td></tr>
    <tr><td class="paramname">precision</td><td>The number of characters after the decimal point.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts a floating-point complex number to a string in the given base. This string will look like <code>X+Yi</code>, <code>X-Yi</code>, <code>-X+Yi</code>, or <code>-X-Yi</code>. Valid base sizes are from 2 to 36, and anything else is assumed to be base 10. If the precision is 1 or greater, then exactly that many digits will show after the decimal point, otherwise up to <code>Z_STR_FLOAT_PRECISION</code> digits will show (default is 6). </p>

</div>
</div>
<a class="anchor" id="a535efedc62c854b849c57c167305b13f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; ascii &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from an ASCII string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>An ASCII encoded string.</td></tr>
  </table>
  </dd>
</dl>
<p>Copies over characters from the given string, converting them to the appropriate encoding scheme for this string. </p>

</div>
</div>
<a class="anchor" id="a2e6e7832d611f98ac8fa7eb5cb581347"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; utf8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from a UTF-8 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A UTF-8 encoded string.</td></tr>
  </table>
  </dd>
</dl>
<p>Copies over characters from the given string, converting them to the appropriate encoding scheme for this string. </p>

</div>
</div>
<a class="anchor" id="a36e33334d160bab82c66b804ada479cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; utf16 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from a UTF16 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A UTF16 encoded string.</td></tr>
  </table>
  </dd>
</dl>
<p>Copies over characters from the given string, converting them to the appropriate encoding scheme for this string. </p>

</div>
</div>
<a class="anchor" id="a2a7edd60be02b0a5174af2abe27cabc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; utf32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from a UTF32 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A UTF32 encoded string.</td></tr>
  </table>
  </dd>
</dl>
<p>Copies over characters from the given string, converting them to the appropriate encoding scheme for this string. </p>

</div>
</div>
<a class="anchor" id="abdc074690cfd42fd243b6718fccc86fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::~<a class="el" href="classz_1_1core_1_1string.html">string</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lvalue copy-constructor. </p>
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7ebc6a5b873a2d834dbd604548256a38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append another string to the end of this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the other string is appended.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a74e91ace781f0f0d0b30011ab6d3922a" title="Append another string to the end of this one. ">operator+=()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab808c847f34b92d16ce7b5d03feb77f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the character at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the character to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character at the given index, in UTF32 format.</dd></dl>
<p>If the index is greater than the character count, the null character is returned. For UTF-8 strings, if the chracter at the given index is part of a multibyte sequence, that sequence is converted to UTF32 and returned.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#aa7fef7b87b351d545968a364ee5f22a9" title="Get the character at the given index. ">operator[]()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa5a9d20e265f36525db8922c9b57fa5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::beginsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the string begins with a given sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to check for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this string begins with the given sub-string. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a130e7f8527bac3208ac8dbe8b57c19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::camel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all characters in the string to camelcase. </p>
<dl class="section return"><dt>Returns</dt><dd>A duplicate of this string, converted to camelcase. </dd></dl>

</div>
</div>
<a class="anchor" id="a34d4052c0c352352e49e020ded382eb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::chars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the individual character count of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of characters in the string.</dd></dl>
<p>For UTF-8 strings, multibyte sequences are counted count as a single character.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a8ece138e99ff49a4bd56382bed816aeb" title="Get the character count of the string. ">length()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af8669c07cf59dc85ebbd27c3a21771a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;double&gt; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::complex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert this string to a complex value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base this string is being interpreted as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The floating-point complex representation of this string, if it is a valid complex float. 0 otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#acacd7da8f29459c70c0049ccb1ab42bb" title="Check if this string can convert to a complex value. ">isComplex()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a64e4d260010465ba4c9b6042d1b04e96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the occurrences of a sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of times the given sub-string appears in the full string. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1a11acc341f669f44df588a126c8a03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::cstring </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the single-byte cstring pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the string data, if this string is in a single-byte format. <code>NULL</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a11a5b51d54ba1a67e232ce459c76e178"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::cutDuplicates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all sequential duplicates from this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to remove duplicates of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after removing duplicates.</dd></dl>
<p>Removes all contiguous repetitions of the given sub-string, leaving one instance of the sub-string where the group was. </p>

</div>
</div>
<a class="anchor" id="ab9683b4fd5015aa3f9b73489cb4fa0a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::endsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the string ends with a given sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to check for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this string ends with the given sub-string. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d92098b1dbb6d49eadf7a0df9dc8479"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a specific occurrence of a sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to search for. </td></tr>
    <tr><td class="paramname">occurrence</td><td>The occurrence of the sub-string to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the given occurrence of the sub-string, if that occurrence was found. Otherwise, -1.</dd></dl>
<p>Attempts to find given occurrence of the sub-string starting at the <b>beginning</b> of the string. Note that the occurrence starts at 1. If the occurrence is less than 1, then -1 is returned. </p>

</div>
</div>
<a class="anchor" id="a3e9324dc9c2b66f15f260a3dfd569db3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::findAfter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a specific occurrence of a sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to search for. </td></tr>
    <tr><td class="paramname">index</td><td>The index to start at. </td></tr>
    <tr><td class="paramname">occurrence</td><td>The occurrence of the sub-string to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the given occurrence of the sub-string, if that occurrence was found. Otherwise, -1.</dd></dl>
<p>Attempts to find given occurrence of the sub-string, searching forward starting at the given index. Note that the occurrence starts at 1. If the occurrence is less than 1, then -1 is returned. </p>

</div>
</div>
<a class="anchor" id="aa3c119f72cb30db17bedcd6bd47866fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::findBefore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse-find a specific occurrence of a sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to search for. </td></tr>
    <tr><td class="paramname">index</td><td>The index to start at. </td></tr>
    <tr><td class="paramname">occurrence</td><td>The occurrence of the sub-string to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the given occurrence of the sub-string, if that occurrence was found. Otherwise, -1.</dd></dl>
<p>Attempts to find given occurrence of the sub-string, searching backward starting at the given index. Note that the occurrence starts at 1. If the occurrence is less than 1, then -1 is returned. </p>

</div>
</div>
<a class="anchor" id="aa29dccb5c3e1f52db8c21e0d9262dc56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::findLast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse-find a specific occurrence of a sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to search for. </td></tr>
    <tr><td class="paramname">occurrence</td><td>The occurrence of the sub-string to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the given occurrence of the sub-string, if that occurrence was found. Otherwise, -1.</dd></dl>
<p>Attempts to find given occurrence of the sub-string starting at the <b>end</b> of the string. Note that the occurrence starts at 1. If the occurrence is less than 1, then -1 is returned. </p>

</div>
</div>
<a class="anchor" id="aeb8d5137e0941a24b1e523f456c260ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::floating </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert this string to a floating-point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base this string is being interpreted as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The floating-point representation of this string, if it is a valid float. 0 otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a3c25c7b1c7b83f89f27b817067435918" title="Check if this string can convert to a floating-point value. ">isFloating()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac160a02dcc5ca76456bfcbf4638c28d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr encoding <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::format </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the encoding of this string. </p>
<dl class="section return"><dt>Returns</dt><dd>An integer indicating this string's encoding.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="encoding_8h_source.html">encoding.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9556b726933f79af8bdf4a5794768f66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::foundAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a sub-string is found at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to check for. </td></tr>
    <tr><td class="paramname">index</td><td>The index in the string to look at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sub-string was found beginning at the given index. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aadc3f1f53816a5309fddc8f370862def"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::foundEndAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a sub-string ends at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to check for. </td></tr>
    <tr><td class="paramname">index</td><td>The index in the string to look at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sub-string was found ending at the given index. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aca681e97ec1f2142c36bc15a2d6deba4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert another string into this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to insert. </td></tr>
    <tr><td class="paramname">index</td><td>The index to insert before.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the other string is inserted.</dd></dl>
<p>Inserts the given string before the given index. So, for <code>B = "abc"</code> and <code>A = "xyz"</code>, <code>A.insert(B,0)</code> would give <code>"abcxyz"</code>, <code>A.insert(B,1)</code> would give <code>"xabcyz"</code>, etc. </p>

</div>
</div>
<a class="anchor" id="a14b2c3667a94126667653e8266b6577e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::integer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert this string to an integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base this string is being interpreted as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A signed integer representation of this string, if it is a valid integer. 0 otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a6dde7e9fb2c7006fc653e173c64fb7fe" title="Check if this string can convert to an integer. ">isInteger()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acacd7da8f29459c70c0049ccb1ab42bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::isComplex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if this string can convert to a complex value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base this string is being interpreted as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the string contains only characters representing a floating-point complex number. False otherwise.</dd></dl>
<p>Valid strings must follow the form <code>X+Yi</code> or <code>Xi+Y</code>, where <code>X</code> and <code>Y</code> are floating-point values. <code>X</code> may optionally have a <code>+</code> or <code>-</code> preceding it, and <code>Y</code> may be preceded by a <code>-</code> instead of a <code>+</code>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a3c25c7b1c7b83f89f27b817067435918" title="Check if this string can convert to a floating-point value. ">isFloating()</a> </dd>
<dd>
<a class="el" href="classz_1_1core_1_1string.html#af8669c07cf59dc85ebbd27c3a21771a8" title="Convert this string to a complex value. ">complex()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3c25c7b1c7b83f89f27b817067435918"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::isFloating </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if this string can convert to a floating-point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base this string is being interpreted as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the string contains only characters representing a float. False otherwise.</dd></dl>
<p>Valid strings may optionally begin with a <code>+</code> or <code>-</code>, and contain only one period (decimal point). The number may also have an exponent in the same base, in the form <code>XXeY</code>, where the exponent <code>Y</code> may optionally begin with a <code>+</code> or <code>-</code>. Unlike the main number, this exponent must be an integer.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#aeb8d5137e0941a24b1e523f456c260ec" title="Convert this string to a floating-point value. ">floating()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6dde7e9fb2c7006fc653e173c64fb7fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::isInteger </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if this string can convert to an integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base this string is being interpreted as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the string contains only characters representing a signed integer. False otherwise.</dd></dl>
<p>Valid strings may contain only numeric characters in the given base, and may optionally begin with a <code>+</code> or <code>-</code>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a14b2c3667a94126667653e8266b6577e" title="Convert this string to an integer. ">integer()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8ece138e99ff49a4bd56382bed816aeb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the character count of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of characters in the string.</dd></dl>
<p>For UTF-8 strings, multibyte sequences are counted as multiple characters.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a34d4052c0c352352e49e020ded382eb5" title="Get the individual character count of the string. ">chars()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aab4c1fb525e6d99631fa34594ce37856"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::lower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all characters in the string to lowercase. </p>
<dl class="section return"><dt>Returns</dt><dd>A duplicate of this string, converted to lowercase. </dd></dl>

</div>
</div>
<a class="anchor" id="ac597cf4800109be5d57875e918498570"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t* <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::nstring </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the two-byte cstring pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the string data, if this string is in a two-byte format. <code>NULL</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a83d92960f8b55d2726607ae72d9d3e50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the strings do not exactly match. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa47ffefe13f1ee573e4f0a020cd3afe7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of this and the given string.</dd></dl>
<p>Appends the given string to the end of this string's characters and returns the result. This string is not modified. </p>

</div>
</div>
<a class="anchor" id="a74e91ace781f0f0d0b30011ab6d3922a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append another string to the end of this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the other string is appended.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#a7ebc6a5b873a2d834dbd604548256a38" title="Append another string to the end of this one. ">append()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a92cc49d709ebcb37b40c1352e53f8f3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Less-than comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this string comes before the given string alphabetically. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b6ed070a6d32f0b1af05ba1f10cb5a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than or equal comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this string does not come after the given string alphabetically. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a92467431a93dafbc4349e266c6083b4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the contents of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after assignment.</dd></dl>
<p>Copies all characters from the given string over to this string, replacing current data. </p>

</div>
</div>
<a class="anchor" id="adfb3470ad2b461dfab6ca4fddc210b6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the strings exactly match. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3188d5c2d80de7ca4d9f6a0ff2caa2d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greater-than comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this string comes after the given string alphabetically. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a74e196397c884a26b9b54d8a52641ea5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than or equal comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this string does not come before the given string alphabetically. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7fef7b87b351d545968a364ee5f22a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the character at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the character to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character at the given index, in UTF32 format.</dd></dl>
<p>If the index is greater than the character count, the null character is returned. For UTF-8 strings, if the chracter at the given index is part of a multibyte sequence, that sequence is converted to UTF32 and returned.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classz_1_1core_1_1string.html#ab808c847f34b92d16ce7b5d03feb77f5" title="Get the character at the given index. ">at()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5c751f00887e9aec65ca0fecdf2888ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::padLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>padSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-pad this string up to a given chracter count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to pad on the left of this string. </td></tr>
    <tr><td class="paramname">padSize</td><td>the number of characters to pad up to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after padding.</dd></dl>
<p>If the given string contains more than one character, then some of that string's characters may be cut off in the resultant string. If the pad size is equal or less than the current chracter count, then no padding will be added. </p>

</div>
</div>
<a class="anchor" id="a99afadac69e5c4b1ea90e0c80d73092e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::padRight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>padSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right-pad this string up to a given chracter count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The string to pad on the left of this string. </td></tr>
    <tr><td class="paramname">padSize</td><td>the number of characters to pad up to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after padding.</dd></dl>
<p>If the given string contains more than one character, then some of that string's characters may be cut off in the resultant string. If the pad size is equal or less than the current chracter count, then no padding will be added. </p>

</div>
</div>
<a class="anchor" id="a047e728df74bc7ea0ab801716640fbc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classz_1_1core_1_1inputStream.html">inputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read string data from a stream until the given delimiter is encountered. </p>
<p>Reads until the delimiting character is encountered, or the stream is exhausted. If the delimiter is 0 or not given, the delimiter is assumed to be any white space character. Leading delimiter characters are skipped over until a non-delimiter character is encountered or the stream is exhausted. Any data this string contains is wiped when this function is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to read from. </td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter to read until. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa9e2cfd0c1f533783214e36b7943879"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::readln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classz_1_1core_1_1inputStream.html">inputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read string data from a stream until a newline is encountered. </p>
<p>Reads until a newline is encountered (either <code>\r\n</code> or <code>\n</code>), or the stream is exhausted. Leading newlines are not skipped, so as to allow for empty lines. Any data this string contains is wiped when this function is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to read from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1ceba196566b8c42e61e860411f6a6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove occurrences of the given sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sub-string to remove. </td></tr>
    <tr><td class="paramname">occurrence</td><td>The occurrence to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the sub-string is removed.</dd></dl>
<p>If the occurrence is 0, all occurrences of the sub-string are removed. If the occurrence is negative, then none are removed. Otherwise, only the specified occurrence of the sub-string is removed from the main string, starting from the beginning. </p>

</div>
</div>
<a class="anchor" id="aef27468b8aa1926f0d771e05f06562f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a subset of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The starting index. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the characters are removed.</dd></dl>
<p>If count is 0, no characters are removed. If count is negative, characters are removed in reverse order. </p>

</div>
</div>
<a class="anchor" id="ae3a352e8676093675d0fb029bc8d9c19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>findStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>replStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>occurrence</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace occurrences of the given sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">findStr</td><td>The sub-string to replace. </td></tr>
    <tr><td class="paramname">replStr</td><td>The string to replace the sub-string with. </td></tr>
    <tr><td class="paramname">occurrence</td><td>The occurrence to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the sub-string is replaced.</dd></dl>
<p>If the occurrence is 0, all occurrences of the sub-string are replaced. If the occurrence is negative, then none are replaced. Otherwise, only the specified occurrence of the sub-string is replaced, starting from the beginning of this string. </p>

</div>
</div>
<a class="anchor" id="a48d012318f44f3e5e3e2e1bd971341f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a subset of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The starting index. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to remove. </td></tr>
    <tr><td class="paramname">other</td><td>The string to replace the subset with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the characters are replaced.</dd></dl>
<p>If count is 0, no characters are replaced. Characters are replaced in forward-order whether count is positive or negative. </p>

</div>
</div>
<a class="anchor" id="a0515d4ce68ea76fd5d480c4e9ab9a252"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::serialIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classz_1_1core_1_1inputStream.html">inputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the object's binary data from a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to read from. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classz_1_1core_1_1serializable.html#a66821a8de1a3f4f336cc335cb3ab0b5a">z::core::serializable</a>.</p>

</div>
</div>
<a class="anchor" id="aedb5e002571fe8fa3c7c7c360702227e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::serialOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classz_1_1core_1_1outputStream.html">outputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the object's binary data to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to write to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classz_1_1core_1_1serializable.html#a1b8dd7caf9959c59d8ea07702e1a491b">z::core::serializable</a>.</p>

</div>
</div>
<a class="anchor" id="a53eeb89cc5d269014a945968597e38c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the string in memory. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in memory this string currently consumes. </dd></dl>

<p>Implements <a class="el" href="classz_1_1core_1_1sizable.html#ac608fc50670d4616c956c7663e7d5714">z::core::sizable</a>.</p>

</div>
</div>
<a class="anchor" id="a85444b48a6d7fc97801080db8679e0ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a sub-string from this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The sub-string starting index. </td></tr>
    <tr><td class="paramname">count</td><td>The number of characters in the sub-string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A subset of the original string.</dd></dl>
<p>If count is 0, a null string is returned. If count is negative, characters are added in reverse order. <br/>
 e.g. for <code>string str = "example"</code>, <code>str.substr(2,3)</code> will give <code>"amp"</code>, and <code>str.substr(5,-3)</code> will give <code>"pma"</code>. </p>

</div>
</div>
<a class="anchor" id="a4692a7a8aceb41ba7f5281183d642afc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::trim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove padding from the both sides of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The pad string to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after removing padding.</dd></dl>
<p>Removes all occurrences of the given pad string from the left and right sides of this string. </p>

</div>
</div>
<a class="anchor" id="a831d59c0272e84650709aafedde14419"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::trimLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove padding from the left side of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The pad string to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after removing left-padding.</dd></dl>
<p>Removes all occurrences of the given pad string from the left side of this string. </p>

</div>
</div>
<a class="anchor" id="a2746636a6364150dd3173e20b6e255e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&amp; <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::trimRight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classz_1_1core_1_1string.html">string</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove padding from the right side of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The pad string to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after removing right-padding.</dd></dl>
<p>Removes all occurrences of the given pad string from the right side of this string. </p>

</div>
</div>
<a class="anchor" id="a2fb9e82aa54fb7bb1fc08a1930d2f2ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classz_1_1core_1_1string.html">string</a> <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::upper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all characters in the string to uppercase. </p>
<dl class="section return"><dt>Returns</dt><dd>A duplicate of this string, converted to uppercase. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f90a793a0a4003329ddeb7a15a2f537"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classz_1_1core_1_1outputStream.html">outputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write string data to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a860593a1714db9eee57b898072370d92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::writeln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classz_1_1core_1_1outputStream.html">outputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write string data to a stream, appending a newline. </p>
<p>Actual characters in the newline depends on operating system (usually <code>\n</code>, <code>\r\n</code> on Windows).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e684f962c14ef88c1fe5bde851091e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;encoding E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t* <a class="el" href="classz_1_1core_1_1string.html">z::core::string</a>&lt; E &gt;::wstring </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the four-byte cstring pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the string data, if this string is in a four-byte format. <code>NULL</code> otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/travis/build/ZacharyWesterman/libzed/z/core/<a class="el" href="string_8h_source.html">string.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
